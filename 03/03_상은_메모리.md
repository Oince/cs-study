# 메모리

- CPU가 실행할 프로그램 코드와 데이터를 저장하는 물리적 장치
- 실행될 프로그램의 코드와 데이터는 메모리에 적재되고, 프로그램의 실행 중 발생하는 데이터 또한 메모리에 저장됨
- CPU는 메모리에 있는 코드와 데이터를 CPU 내부로 읽어 와서 계산하고 필요에 따라 결과를 메모리에 저장

# 메모리 계층 구조

<img width="867" height="453" alt="image" src="https://github.com/user-attachments/assets/617e829f-caf5-44eb-baf4-82c9cd3395b0" />

| 분류 | 용도 | 휘발성 | 속도 | 용량 |
| --- | --- | --- | --- | --- |
| CPU 레지스터 | 몇 개의 명령과 데이터 저장 | O | 가장 빠름 (< 1ns) | 가장 작음 (바이트 단위) |
| 캐시 (L1, L2, L3) | 한 코어에서 실행되는 명령과 데이터 저장 (L1, L2)
멀티 코어들에 의해 공유되는 명령과 데이터 저장 (L3) | O | 빠름 (< 5ns) | 작음 (KB 단위 / L3는 MB 단위) |
| 주기억장치 (메모리, RAM) | 실행 중인 전체 프로세스들의 코드와 데이터, 입출력 중인 파일 블록 저장 | O | 보통 (< 50ns) | 보통 (GB 단위) |
| 보조기억장치 (HDD, SSD) | 파일이나 데이터베이스, 그리고 메모리에 적재된 프로세스의 코드와 데이터의 일시저장 | X | 느림 (< 20ms) | 큼 (TB 단위) |

## 메모리 계층 구조의 필요성 (용량과 속도의 Trade-off)

언제나 Trade-off는 존재한다!
성능을 위해 속도와 용량의 상호 보완을 위하여 메모리 계층 구조를 고안하였다.

이 때 고려한 것이, 참조 지역성이다.
또한, 메모리 구조의 상층으로 갈 수록 가격이 비싸지기에 경제성 등 다양한 부분을 고려하여 만들어졌다고 보면 된다.

<img width="1397" height="607" alt="image" src="https://github.com/user-attachments/assets/b9fe06ce-6418-4d8d-b96e-e72b12f03df5" />

### 참조 지역성 (Locality of Reference)

자주 쓰는 데이터는 계속 자주 쓰이고(반복되어 쓰이고), 자주 쓰이지 않는 데이터는 계속 자주 쓰이지 않는다

따라서, 자주 쓰일 것 같은 데이터는 캐시 메모리로 읽어와, 메모리까지 가지 않고 캐시에서 해결하여 시간을 단축시키는 것이다.

자주 쓰이는 데이터는 전체 데이터 양에 비해 적은 양이기에, 캐시는 메모리보다 좀 더 작아도 되는 것이다.

따라서, 프로세서가 필요로 하는 데이터를 최대한 가까운 곳에 위치시켜 속도를 향상시킬 수 있도록 하는 것이다.

## SRAM과 DRAM

메모리에 이용되는 반도체도 종류가 몇 있다.

그 중 대표적으로 SRAM과 DRAM이 있는데, 차이점을 조금 정리해 보았다.

|  | DRAM (Dynamic Random Access Memory) | SRAM (Static Random Access Memory) |
| --- | --- | --- |
| 사용 용도 | 메인 메모리, 모바일 기기 | 캐시 메모리, 임베디드 시스템 |
| 속도 | 상대적으로 느림 (10-100ns) | 빠름(1-10ns) |
| 전력 소모 | 셀 구조가 단순하여(1트랜지스터 + 1커패시터) 셀 당 소비 전력은 적지만,
주기적인 리프레시(refresh)가 필요해 전체적인 전력 소모가 비교적 크다 | 리프레시가 불필요하고 안정적이지만,
6트랜지스터 플립플롭 구조로 셀 당 소비 전력이 크며, 고집적화에 불리하여 총 전력 소모도 높다 |
| 제조 비용 | 낮음 | 높음 |
| 시장 가격 | 상대적으로 저렴 | 일반적으로 높음 |
| 용량 대비 크기 | 작음 (고밀도 가능) | 큼 (트랜지스터 다수 사용으로 더 많은 공간 차지) |
| 장점 | 대용량 제조, 제조 및 판매 가격 저렴, 공간 효율적 | 빠른 접근 속도, 리프레시 필요 없고 안정적, 낮은 지연 시간 |
| 단점 | 주기적 리프레시 필요, 상대적으로 느린 접근 속도 | 제조 및 판매 가격 높음, 더 많은 공간 차지 |
| 주요 구조 | 1 트랜지스터 + 1 캐패시터 | 6 트랜지스터로 플립플롭 회로 사용 |
| 리프레시 필요성 | 있음 (수 ms 주기로 재충전) | 없음 |

# 메모리 관리

기술의 발전으로 메모리 용량이 증가하면서, 프로그램의 크기 또한 계속 증가하고 있다.
따라서, 메모리는 언제나 부족한 상황이다.

이렇듯, 한정된 메모리의 효율적인 사용과 메모리 참조 방식을 제공하기 위해서는 메모리 관리 전략이 필요하다.

### 운영체제에 의해 메모리 관리가 필요한 이유

- 메모리는 공유 자원: 여러 프로세스 사이에 메모리 공유, 각 프로세스에게 물리 메모리 할당 필요
- 메모리 보호 필요: 프로세스의 독립된 메모리 공간을 보장하고, 사용자 코드로부터 커널 공간을 보호해야 함
- 메모리 용량 한계 극복: 설치된 물리 메모리보다 큰 프로세스에 대해 지원이 필요
- 메모리 효율성 증대: 가능한 한 많은 개수의 프로세스를 실행시키기 위해, 효율적인 메모리 할당 필요

## 효과적인 메모리 사용 (메모리 낭비 방지)

메모리를 효율적으로 관리하기 위해 여러 메모리 낭비 방지 기술들이 존재한다.

- 동적 적재 (Dynamic Loading)
    - 프로그램 실행에 반드시 필요한 루틴과 데이터만 적재하는 것
    - 모든 루틴과 데이터는 항상 사용하지 않고, 실행 시 필요하다면 그 때 해당 부분을 메모리에 적재
- 동적 연결 (Dynamic Linking)
    - 라이브러리 루틴 연결을 컴파일 시점에 하는 것이 아닌 실행 시점까지 미루는 기법
- 스와핑 (Swapping)
    - CPU에서 실행중이 아닌 프로세스는 저장 장치의 Swap 영역으로 이동(Swap in/Swap out)해 메모리를 확보
        - 보조기억장치의 일부분을 떼어내어 만든 backing store라는 공간을 만들어 메인 메모리에서 사용되고 있지 않은 프로세스를 넣어둔다.
        - Swap 영역으로 몰아내는 것을 Swap out이라고 하고, 다시 메인 메모리에 올리는 것을 Swap in이라고 한다.
    - 문맥 교환으로 인한 오버헤드가 발생할 수 있고 속도가 느려지지만, 메모리 공간 확보에는 효율적

## 메모리 관리 전략

이러한 단편화라는 문제를 해결하기 위해 다양한 전략들이 존재한다.

### 단편화

프로세스에게 할당할 수 없는 조각 메모리들(hole)이 생겨 메모리 공간이 충분함에도 불구하고,
프로세스가 메모리에 적재되지 못해 메모리가 낭비되는 현상

- 내부 단편화
    - 가변 분할 방식에서 메모리에 프로세스가 적재되고 제거되는 일이 반복되면서, 여유 공간이 충분함에도 불구하고 이러한 여유 공간들이 조각으로 흩어져 있어(Scattered Hole) 메모리에 프로세스를 적재하지 못해 메모리가 낭비되는 현상
- 외부 단편화
    - 고정 분할 방식에서 프로세스가 실제 사용해야 할 메모리보다 더 큰 메모리를 할당 받아 메모리가 낭비되는 현상
- 압축
    - 외부 단편화를 해소하는 방법으로 Schattered holes를 모으는 방법
    - 이를 합치는 과정에서 메모리에 적재된 프로세스를 정지시키고 한 쪽으로 이동시키는 작업이 필요해 비효율적
    - 또한, 어느 자유공간을 기준으로 모을지 결정하는 알고리즘도 모호

### 연속 메모리 할당

프로세스를 메모리에 연속적으로 할당하는 기법

할당과 제거를 반복하다 보면 Scattered holes가 생겨나고, 이로 인한 외부 단편화가 발생.
이러한 외부 단편화를 줄이기 위해 다양한 할당 방식이 존재

- 최초 적합 (First fit)
    - 가장 처음 만나는 빈 메모리 공간에 프로세스 할당
    - 메모리를 순차적으로 훑다가 맨 처음으로 들어갈 수 있는 자리에 넣어버린다
    - 빠르다
- 최적 적합 (Best fit)
    - 빈 메모리 공간의 크기와 프로세스의 크기 차이가 가장 적은 곳에 할당
    - 전체를 탐색한 후 가장 크기가 밀접한 공간에 집어넣는다
- 최악 적합 (Worst fit)
    - 빈 메모리 공간의 크기와 프로세스의 크기 차이가 가장 큰 곳에 프로세스를 할당
    - 이렇게 생긴 빈 메모리 공간에 또 다른 프로세스를 할당할 수 있을 것이라는 가정에 기인

### 페이징 (Paging)

가상 메모리를 페이지 단위로 나누어서 물리 메모리에 같은 크기인 프레임과 매핑하여 사용하는 것

연속적인 물리 메모리가 아니더라도, 원하는 크기의 프레임을 사용할 수 있게 됨

- 메모리 공간이 연속적으로 할당되어야 한다는 제약 조건을 없애는 메모리 전략
- 논리 메모리는 고정 크기의 페이지, 물리 메모리는 고정 크기의 프레임 블록으로 나누어 관리
- 프로세스가 사용하는 공간을 논리 메모리에서 여러 개의 페이지로 나누어 관리하고, 개별 페이지는 순서에 상관없이 물리 메모리에 있는 프레임에 매핑되어 저장
- MMU의 재배치 레지스터 방식을 활용하여 CPU가 마치 프로세스가 연속된 메모리에 할당된 것처럼 인식하도록 함
- 논리 메모리는 물리 메모리에 저장될 때 연속되어 저장될 필요가 없고, 물리 메모리의 남는 프레임에 적절히 배치되기 때문에 외부 단편화가 생기지 않음
- 내부 단편화 문제가 발생할 수 있음
    - 프로세스의 크기가 페이지 크기의 배수가 아니라면 마지막 프로세스의 페이지는 한 프레임을 다 채울 수 없다. 따라서, 이런 공간이 메모리 안에서 빈 공간으로 남아 내부 단편화 문제가 발생하게 될 수 있다.

❔ 가상 메모리란? (간단히 다뤄봄)

물리적 메모리 크기의 한계를 극복하기 위해 나온 기술.
물리 메모리보다 큰 프로세스를 수행하기 위해 가상 메모리를 사용.

내 컴퓨터는 100MB의 메모리 크기를 갖고 있는데 200MB 크기의 프로세스를 수행할 수 있도록 해야 하는 등, 필요한 부분만 메모리에 적재하고 프로세스를 실행 시 실행에 필요한 부분만 메모리에 올리는 것이다.

### 세그맨테이션 (Segmentation)

서로 크기가 다른 논리적인 단위 세그먼트로 분할하고 메모리를 할당하여 물리 메모리의 주소로 주소 변환을 수행

세그먼트들의 크기가 서로 다르기에 페이징 기법처럼 미리 분할해 둘 수는 없고 메모리에 적재될 때 빈 공간을 찾아 할당하는 가상 메모리 관리 기법

- 각 프로세스에 알맞게 메모리를 할당하여 내부 단편화가 발생하지 않음
- 보호와 공유 기능 수행 가능
    - 프로그램의 중요한 부분과 중요하지 않은 부분을 분리하여 저장할 수 있고, 같은 코드 영역은 한 번에 저장할 수 있다는 점
- 서로 다른 크기의 세그먼트들에 의해 필요시 메모리에 올리고, 필요 없을 경우 내리는 작업을 반복하다 보면 외부 단편화가 생길 수 있음

# 참고자료

https://velog.io/@passion_man/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-8.-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC

https://hotechstory.tistory.com/59

https://dheldh77.tistory.com/entry/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC-%EC%A0%84%EB%9E%B5Memory-Management-Strategy

https://rebro.kr/178

https://charles098.tistory.com/101

https://nayoungs.tistory.com/entry/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B3%84%EC%B8%B5-%EA%B5%AC%EC%A1%B0Memory-Hierachy

https://good-potato.tistory.com/64

https://deeppago.tistory.com/53#c1

https://rebro.kr/178
