# 운영체제 구조

## 운영체제란?

운영체제는 하드웨어를 쉽고 효율적으로 사용할 수 있는 추상화를 제공하고, 자원의 공유 및 분배를 위한 정책을 결정한다.

컴퓨터의 주요 자원들을 다음과 같이 추상화해서 제공한다

- cpu: 프로세스
  - 실행되고 있는 프로그램
  - 각 프로그램을 구별해서 실행시키기 위함
  - 프로세스의 생성과 삭제, 어떤 프로세스을 실행시킬지(스케줄링) 결정

- memory: 주소 공간
  - 프로세스가 차지하는 메모리 공간
  - 각 프로세스의 독립적인 메모리 공간을 보호하기 위함
  - 어떤 프로세스를 메모리에 적재하고 제거할 것인지 결정

- disk: 파일
  - 파일을 어떤 방식으로 저장할지 결정

## System call

CPU에는 2가지 이상의 실행 모드가 있다. **mode bit**가 어떤 모드인지 구별한다. 모드를 나누는 이유는 잘못된 사용자로부터 시스템을 보호하기 위해서다. 

모드는 커널 모드와 유저 모드로 나뉘며, 모드에 따라 접근할 수 있는 메모리나 실행 가능한 명령어가 제한된다.

- **커널 모드**
  - 모든 권한을 가진 모드
  - 운영 체제가 실행되는 모드
  - privilege 명령어 및 레지스터 접근 가능
  - 하드웨어 직접 제어 가능
- **유저 모드**
  - 커널 모드에 비해 낮은 권한
  - 어플리케이션이 실행되는 모드
  - privilege 명령어 실행 불가능

**시스템 콜**은 유저 모드에서 커널 모드로 진입하기 위한 인터페이스다. 유저 프로그램에서 커널이 제공하는 서비스를 이용하기 위해서는 시스템 콜을 호출해야 한다. 

응용 프로그램 개발자는 이런 시스템 콜을 직접 호출하는 것이 아닌 POSIX API와 같은 API로 호출한다. 이런 API들은 사용하는 언어의 라이브러리에 구현되어 있으며 내부적으로 실제 시스템 콜을 호출한다. API를 사용하면 사용자는 시스템 콜의 상세한 명세를 알 필요 없이 간편하게 호출할 수 있다는 장점이 있다. 

## Interrupt

**인터럽트**는 비동기적 이벤트를 처리하기 위한 기법이다. 장치 컨트롤러 또는 하드웨어 오류로 인해 인터럽트가 발생한다.

CPU에는 **인터럽트 요청 라인**이라는 선이 존재한다. 명령어가 실행될 때마다 CPU가 이 선을 감지한다. 라인에 신호가 들어오면 CPU는 인터럽트 번호를 사용해서 인터럽트를 처리하는 **인터럽트 핸들러 루틴**으로 점프해서 인터럽트를 처리한다. 

인터럽트를 처리하고 CPU가 중단된 작업으로 다시 돌아올 수 있어야 한다. 때문에 인터럽트를 처리하기 전에 이전의 상태를 저장해놓아야 하며, 원래의 작업으로 복귀하기 전에 상태를 복원해야 한다. 인터럽트 핸들러는 레지스터의 값을 저장해 두었다가 다시 복원해서 이전의 실행 흐름으로 복귀할 수 있도록 한다.

인터럽트는 매우 자주 발생하기 때문에 빠르게 처리되어야 한다. 그러기 위해서 실행되어야 하는 루틴에 대한 포인터를 저장해놓은 테이블을 이용한다. 이를 **인터럽트 벡터**라고 한다. 인터럽트 번호가 인터럽트 벡터의 테이블 오프셋으로 사용된다. 인터럽트 벡터의 주소 개수보다 더 많은 장치가 존재하기 때문에 **인터럽트 체인**을 이용한다. 하나의 주소에 여러개의 인터럽트 핸들러가 연결 리스트 형태로 이어져 있고, 인터럽트가 호출되면 핸들러들을 하나씩 순회하면서 알맞은 핸들러를 찾는다.

인터럽트에는 우선 순위가 존재한다. 우선순위를 구현하기 위해 인터럽트 라인을 2가지 종류로 구성한다. 첫번째는 마스크 불가 인터럽트다. 회복 불가능한 메모리 오류과 같은 이벤트에 사용된다. 두번째는 마스크 가능 인터럽트다. 이 라인은 장치 컨트롤러가 사용하며, 인터럽트로 방해받지 않아야 하는 작업을 수행중일 때 끌 수 있다.

인터럽트는 하드웨어 인터럽트와 소트프웨어 인터럽트로 나뉜다. **하드웨어 인터럽트**는 말 그대로 하드웨어에 의해서 일어난다. I/O 장치나 타이머 등에 의해서 발생된다. 비동기적으로 발생한다는 특징이 있다. **소프트웨어 인터럽트**는 현재 실행중인 소프트웨어에 의해 발생한다. 동기적으로 발생하며 트랩이라고도 한다. divide-by-zero, 페이지 폴트, 시스템 콜 호출 등의 상황에서 발생한다.

> csapp에서는 크게 예외 상황이 존재하고, 예외의 종류로 interrupt, trap, falut, abort 4가지가 있다고 설명한다
>
> |           | 이유                                               | 동기/비동기 | 리턴                          |
> | --------- | -------------------------------------------------- | ----------- | ----------------------------- |
> | interrupt | I/O 장치에서 발생                                  | 비동기      | 항상 다음 명령어로 리턴       |
> | trap      | 의도적인 예외 발생, 주로 시스템 콜 호출에서 발생함 | 동기        | 항상 다음 명령어로 리턴       |
> | fault     | 회복 가능한 에러가 발생했을 때(페이지 폴트 등)     | 동기        | 현재 실행중이던 명령어로 리턴 |
> | abort     | 회복 불가능한 에러                                 | 동기        | 리턴하지 않고 프로그램 종료   |
>
> 차이를 알아보니 운영체제 관점에서 보면 하드웨어 인터럽트, 소프트웨어 인터럽트로 나뉘고, CPU 아키텍쳐적 관점에서 보면 위의 4가지로 나뉜다고 한다. 관점의 차이이기 때문에 뭐가 맞고 틀린건 없는듯하다.

