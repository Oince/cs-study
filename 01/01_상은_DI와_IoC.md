### 🐳요약
IoC는 `제어권을 스프링에게 넘기는 개념`

DI는 `그 제어권을 활용해 의존성을 주입하는 구현 방식(디자인 패턴)`

스프링이 가지고 있는 컨셉 중, 중요하게 다뤄지는 컨셉이 몇 가지 존재한다.

그 중, DI(의존성 주입)와 IoC(제어의 역전)에 대해 알아보도록 하자

# IoC (Inversion of Control, 제어의 역전)

> `원칙` `개념`
> 
> 
> 사용할 객체를 직접 생성하지 않고, 객체의 생명주기 관리를 외부(스프링 컨테이너)에 위임
> 

## ‘제어’와 ‘제어의 역전’

> 무엇을 제어하고, 무엇을 역전하는 것일까?
> 

### 제어

소프트웨어에서 객체의 생성과 의존 관계 설정, 객체 사용, 객체 소멸 등 애플리케이션의 흐름과 동작을 누가 결정하는 지를 의미

전통적인 방식에서는 개발자가 직접 객체를 만들고 의존성을 설정하여, 전체 흐름을 직접 코드에서 제어한다.

### 제어의 역전

객체를 클래스 내부에서 직접 생성하고 제어하는 것이 아니라, 외부에서 인자로 받아 초기화 하는 것

즉, 객체의 생성과 객체 간의 관계 정의, 라이프사이클 관리 등의 제어권이 개발자가 아닌 프레임워크(스프링 컨테이너)로 역전되는 것

### 간단 예시

**샌드위치를 먹기** 위한 나의 행동
<img width="928" height="416" alt="image" src="https://github.com/user-attachments/assets/7fa358aa-e602-4ea9-af02-4399865f8b22" />

- `전통적 방식`
    - 나는 샌드위치에 넣을 재료 선정, 어떤 순서로 재료를 얹을지, 어떻게 조리할 지, 조리 후 설거지 등을 모두 내가 관리하고 처리해야 한다.
    (내가 제어)
- `IoC`
    - 나는 어떤 샌드위치를 먹고 싶은지만 주문(요구사항 정의)하면,
    그 주문에 따라 샌드위치 전문점에서 알아서 샌드위치를 만들어 나에게 제공해 준다.
    (제어권을 외부로 넘김)
    - 샌드위치를 만드는 과정 전체에 대한 **제어권**은 샌드위치 전문점에게로 넘어가는 것.
    - 나는 주문한 샌드위치를 받아 먹기만 하면 된다.
    샌드위치 재료 선정, 조리 과정, 뒷처리 등은 내가 신경 쓸 필요가 없다.

👉 정리

내 주 목적은 **샌드위치를 먹는 것(=비즈니스 로직 구현)**

- 내가 직접 샌드위치를 만들 필요 없이, 주문만 하면 샌드위치 가게가 샌드위치를 만들어 준다. 나는 그럼 먹기만 하면 되네!
- 내가 직접 객체를 만들거나 관리할 필요 없이(내가 제어할 필요 없이), 필요한 객체만 명시해 두면, 컨테이너가 알아서 생성해주고, 의존성 주입 및 관리까지 모두 알아서 관리해준다.
나는 그럼 비즈니스 로직에만 집중하면 되는 거네!

## 제어의 역전 (Inversion of Control)

```java
// [전통적 방식] 의존성을 직접 생성 → 제어권이 개발자에게 있음
@RestController
public class UserController {
		// 객체를 생성하고 사용하는 작업을 개발자가 **직접 제어**
		private final UserService userService = new UserServiceImpl();
}
```

```java
// [IoC + DI] 스프링 컨테이너가 의존성 생성·관리 → 제어권이 컨테이너에 있음
@RestController
@RequiredArgsConstructor  // 방법 1. lombok 이용하여 final 필드 대상 생성자 자동 생성
public class UserController {
		private final UserService userService;
		
		// 방법 2. 생성자 주입
		public UserController(UserService userService) {
        this.userService = userService;
    }
}
// 방법 1, 2 중 둘 중 하나만 사용하면 됨
// 그 외에도 여러 방법이 존재
```

이와 같이 내가 직접 UserService 구현체를 생성할 필요 없이,
아래처럼 UserService 객체가 필요하다고 명시되어 있으면 스프링 컨테이너가 알아서 객체를 관리하고 구현체를 주입해 준다.

IoC에서 중요한 것은

`스프링 컨테이너가 객체 관련 귀찮은 일들(생성, 주입, 삭제, 관리 등)을 해 준다` 라는 것!

= 개발자가 관리하기 귀찮은 것을 스프링 컨테이너가 대신 해 주는 것!

🐳 IoC를 설명할 수 있는 또다른 예제는, 템플릿 메서드 패턴!

- 상위의 추상 클래스에 흐름을 제어하는 메서드를 정의해 두고,
해당 템플릿 메서드에서 사용할 하위 메서드들은 변경이 필요 없으면 공통 메서드로,
변경이 필요하면 추상 메서드로 정의해 둔다.
- 이후 해당 클래스를 상속받는 클래스에서 추상 메서드를 구현하여 사용하게 된다.

⇒ 하위 메서드에서 실제 구현을 하지만, 메서드의 호출 제어권은 상위의 추상 클래스에 존재!
      = 제어의 역전

# DI (Dependency Injection, 의존성 주입)

> `행위` `디자인 패턴`
> 
> 
> 사용할 객체를 직접 생성하지 않고 외부 컨테이너가 생성한 객체를 주입받아 사용하는 방식
> 
- IoC를 구현하는 다양한 디자인 패턴 중 하나 → 외부에서 제어를 받는 방법 중 한 가지 = 의존성 주입

```java
// [IoC + DI] 스프링 컨테이너가 의존성 주입 -> 제어권이 컨테이너에 있음
@RestController
@RequiredArgsConstructor
public class UserController {
		private final UserService userService;
}
```

해당 코드에서는 컨테이너로부터 의존성을 주입받게 된다. (`@RequiredArgsConstructor`)

개발자는 이것이 필요하다고 명시해 두면 스프링 컨테이너가 이에 맞는 인자를 가져와 사용할 수 있도록 주입해 준다.

## 의존성이란?

한 요소가 다른 요소를 필요로 하거나 기대고 있는 관계.
즉, 어떤 객체나 모듈, 클래스가 자신의 기능을 수행하기 위해 다른 객체나 모듈에 의존하게 되는 것

위 코드에서는 사용자의 요청을 받아 처리해야 하는 Controller의 기능을 수행하기 위해서는
요청 값을 이용하여 그에 맞는 응답을 전달해 줄 수 있는 비즈니스 로직을 처리하는 Service 객체가 필요하다.
따라서, Controller는 Service를 의존하고 있는 것!

## 의존성 주입

비즈니스 로직에서 어떤 객체(구체 클래스)에 의존할 것인지는 내 로직에게는 TMI이다, 굳이 알 필요 없다.

스프링은 이와 같이 스프링 컨테이너(DI 컨테이너)를 이용하여 강하게 결합된 클래스들을 분리하여 결합도를 낮추고 유연성을 확보해 준다.

스프링 컨테이너가 관리하는 객체들을 Bean이라고 하는데,
애플리케이션 실행 시점에 스프링이 의존성 주입이 필요한 곳에 찾아가 컨테이너에 있는 빈들 중 적절한 빈을 찾아 주입해 준다.

하지만, 매번 이 주입할 객체를 새로 생성하는 것은 너무나도 비효율적이니 스프링에서는 이러한 빈들을 기본적으로 싱글톤으로 관리한다.

## 의존성 주입 방법

의존성 주입 방법은 여러 가지가 존재하는데, 주로 생성자 주입을 추천한다.

1. 생성자 주입 (추천): 생성자 호출 시점에 생성자를 통해 의존 관계 주입
    - 생성자 주입을 사용해야 하는 이유
        - 객체의 불변성 확보
        - 테스트 코드의 작성
        - final 키워드 작성 및 Lombok과의 결합
        - 스프링에 의존하지 않는 코드 (`@Autowired`는 스프링이 제공하는 어노테이션)
        - 순환 참조 에러 방지 (현재는 스프링부트 2.6부터는 순환 참조를 기본적으로 허용하지 않음)
2. Setter 주입: Setter를 통해 의존 관계 주입
    - 주입받는 객체가 변경될 가능성이 있는 경우 사용
3. 필드 주입 - `@Autowired` : 필드에 바로 의존 관계 주입 
    - 외부에서 접근이 불가능하다는 단점
    - 필드 주입은 반드시 DI 프레임워크가 존재해야 함
4. 일반 메서드 주입
    - 수정자 주입과 동일

# 참고자료

https://oneul-losnue.tistory.com/364

https://innovation123.tistory.com/167

https://shinsunyoung.tistory.com/133

https://adjh54.tistory.com/298#2)%20%EC%A0%9C%EC%96%B4%EC%9D%98%20%EC%97%AD%EC%A0%84%20%3AIOC(Inversion%20of%20Control)-1-1

https://my-codinglog.tistory.com/50

https://mangkyu.tistory.com/150

https://mangkyu.tistory.com/125
