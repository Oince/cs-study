# 스레드 (Thread)

> 프로세스가 할당 받은 자원을 이용하는 실행 단위
> 
- 프로세스의 특정한 수행 경로
- 프로세스 내에서 실행되는 여러 흐름의 단위
- 프로세스를 구성하는 실행의 흐름 단위
- CPU 이용의 기본 단위, 소프트웨어 관점에서 논리적 작업 단위

프로세스 내에서 프로세스의 자원을 이용하여 실제로 작업을 수행하는 일꾼과 같다.

## 특징

- 각 스레드는 독자적인 스택 메모리를 갖는다.
    - 스택 공간은 함수 호출 시 전달되는 인자, 지역 변수 등을 저장하는 메모리 공간
    - 독립적인 스택 공간을 가졌다는 것 = 독립적인 함수 호출이 가능하다는 것 = 독립적인 실행 흐름을 가질 수 있다는 것
- 스레드는 프로세스 내에서 각각 스택만 할당 받고 Code, Data, Heap 영역은 공유한다.
- 스레드는 한 프로세스 내에서 동작되는 여러 실행의 흐름으로, 프로세스 내의 주소 공간이나 자원들을 같은 프로세스 내의 스레드끼리 공유하며 실행된다.
- 각각의 스레드는 별도의 레지스터와 스택을 갖고 있지만, 힙 메모리는 서로 읽고 쓸 수 있다.
- 스레드는 메모리를 공유하기 때문에 동기화, 데드락 등의 동시성 문제가 발생할 수 있다.

## 장단점

### 장점

- 응답성(성능) 향상
- 자원 공유 효율성 향상
- 동시성: 여러 개의 스레드가 동시에 실행 가능, 작업을 병렬로 처리할 수 있다.

### 단점

- 스레드 간 상호 간섭: 스레드는 프로세스처럼 독립적인 개체가 아니기에, 서로에게 영향을 미칠 수 있다.
- 성능 저하: 스레드 컨텍스트 스위칭이 존재한다는 점
- 동기화 이슈: 여러 스레드가 공유 자원에 동시에 접근할 때, 동기화 문제 발생
- 자원 소비: 스레드마다 스택 및 레지스터 등의 메모리 자원 소비 → 스레드 증가 시, 메모리 사용량도 증가

## 스레드의 자원 공유

> 프로세스의 4가지 영역(코드, 데이터, 스택, 힙)에서 스레드는 독자적인 스택 메모리를 가진다.
> 
> 
> 그 외에는 프로세스 내 다른 스레드들과 공유된다.
> 

하나의 프로세스를 다수의 실행 단위인 스레드로 구분하여 자원을 공유하고, 자원의 생성과 관리의 중복성을 최소화하여 수행 능력을 올리기 위함 (=효율적인 자원 관리)

두 가지 방식으로 표현해보았다.

<img width="1505" height="709" alt="image" src="https://github.com/user-attachments/assets/d32aab99-a873-4391-8709-560b281cbe56" />

<img width="866" height="486" alt="image" src="https://github.com/user-attachments/assets/11abcedf-f585-4624-b3ef-df1798b7001f" />

이 중, Stack 공간은 함수 호출 시 사용하는 임시 데이터(지역 변수, 매개 변수, 리턴 값 등)이 저장되는 공간

⇒ 독립적인 함수 호출이 가능하다는 것 = 독립적인 실행 흐름을 가질 수 있다는 것

### ➡️ 프로세스의 자원 공유

기본적으로 각 프로세스는 별도의 주소 공간에서 실행되기 때문에 한 프로세스는 다른 프로세스의 변수가 자료 구조에 접근할 수 없다.

하지만, 프로세스 간 정보를 공유하는 방법을 통해 프로세스 자원 공유를 하기도 한다.

- IPC (Inter-Process Communication)
- LPC (Local Inter-Process Communication)
- 별도의 공유 메모리를 만들어 정보 공유

하지만, 프로세스 자원 공유는 단순히 CPU 레지스터 교체 뿐만 아니라 RAM과 CPU 사이의 캐시 메모리까지 초기화되기 때문에 자원 부담이 크다는 단점이 존재.

다중 작업이 필요한 경우, 스레드를 이용하는 것이 훨씬 효율적이다.

⇒ 현대 OS에서는 다중 프로세싱을 지원하지만, 다중 스레딩을 기본으로 설정하고 있다.

## 생명 주기

> 운영체제에서 다중 스레드를 관리, CPU를 사용할 수 있는 스레드를 선택하고 CPU를 할당하는 작업
> 

프로세스 스케줄링과 유사하지만, 하나의 프로세스 내에서 다수의 스레드가 동작하는 형태이기에 스레드 간 상호작용 및 동기화 문제를 고려해야 한다.

### ➡️ 프로세스 스케줄링

> OS가 CPU를 사용할 수 있는 프로세스를 선택하고, CPU를 할당하는 작업
> 

프로세스의 우선 순위, 작업량 등을 고려하여 효율적으로 배치하여 CPU를 효율적으로 사용함으로써 시스템의 성능을 향상시킨다.

- 이 때, CPU가 한 프로세스에서 다른 프로세스로 전환할 때 발생하는 일련의 과정들을
`문맥 교환(Context Switching)`이라고 한다.
- 프로세스가 생성되면 PCB도 함께 생성되는데,  이 PCB 안에 프로세스의 고유 정보들을 넣어 프로세스를 관리한다.
    - 이를 통해 스케줄링을 수행하고, 문맥 교환을 수행하는 등 다양하게 사용된다.

## 상태

> 프로세스 상태처럼, 스레드도 아래와 같이 다양한 상태를 가진다.
> 

| NEW | 스레드가 생성되고 아직 호출되지 않은 상태 |
| --- | --- |
| RUNNABLE | 스레드가 실행되기 위해 기다리는 상태. CPU를 할당받을 수 있는 상태, 언제든 실행할 준비가 되어 있다. |
| BLOCKED | 특정 이벤트(입출력 등)가 발생하여 대기하는 상태. CPU를 할당받지 못하며, 이벤트가 발생하여 다시 RUNNABLE 상태로 전환될 때까지 대기 |
| TERMINATED | 스레드가 실행을 완료하고 종료된 상태. 더 이상 실행될 수 없으며, 메모리에서 제거 |

## TCB (Thread Control Block)

> 스레드에 대한 정보를 담고 있는 자료 구조 (PCB 안에 들어 있음)
> 
- Stack 및 간단한 Register 포인터 정보 만을 저장
- PCB보다 가벼움

## 스레드 컨텍스트 스위칭

> 멀티 스레딩 환경에서 스레드 간 실행을 전환하는 기술
> 
- 하나의 프로세스 내에서 스레드들의 문맥을 교환한다는 점

## 프로세스 컨텍스트 스위칭 VS 스레드 컨텍스트 스위칭

<img width="994" height="416" alt="image" src="https://github.com/user-attachments/assets/c8dec133-1b81-4a2f-b121-1760595e7541" />

## 그래서 왜 굳이 스레드를 사용할까?

- 프로세스를 생성하거나 문맥 교환 작업은 너무 무겁고 잦으면 성능 저하가 발생하는데, 스레드를 생성하거나 Switching하는 것은 그에 비해 가볍다
- 두 프로세스가 하나의 데이터를 공유하려면 메시지 패싱이나 공유 메모리 또는 파이프를 사용해야 하는데, 이는 효율도 떨어지고 개발자가 구현/관리하기도 번거롭다.

# 멀티 스레드

> 하나의 프로세스를 여러 개의 스레드로 구성하고, 각 스레드로 하여금 하나의 작업을 처리하도록 하는 것
> 

하나의 프로세스가 동시에 여러 작업을 실행하도록 하는 것.

### 멀티 스레드와 멀티 프로세스

- 멀티 스레드는 하나의 프로세스 내부에서 여러 개의 스레드가 동시에 실행되는 것
- 멀티 프로세스는 여러 개의 독립적인 프로세스가 동시에 실행되는 것.
    - 하나의 프로세스 작업을 여러 개로 분할하여 병렬로 처리할 수 있는데,
    이 때 프로세스는 스레드 단위로 작업을 분할한다.

### 프로세서 한 개와 프로세서 여러 개

- 프로세서가 하나인 경우 (동시성)
    - 실제로는 각각의 시간에 한 작업만 수행되지만, 병렬적으로 수행되는 것처럼 보이는 것
    - 만약 한 스레드가 blocking 되더라도 커널이 다른 스레드로 switch 시켜 실행할 수 있어, 하나의 프로세서임에도 불구하고 빠른 처리가 가능하고 계산 속도가 증가한다.
- 프로세서가 여러 개인 경우 (병렬성)
    - 여러 작업이 동시에 수행될 수 있다
    - 프로세스의 스레드들이 각각 다른 프로세서에서 병렬적으로 수행될 수 있음
    - 병렬성은 CPU의 개수에 비례

## 멀티 스레딩의 장점

- 응답성 (Responsiveness)
    - 작업을 분리해서 수행하므로 실시간으로 사용자에게 응답 가능
    - 싱글 스레드의 경우, 작업이 끝나기 전까지 사용자에게 응답하지 않음
- 자원 공유 (Resource Sharing)
    - 스레드는 자신이 속한 프로세스 내의 스레드들과 메모리나 자원을 공유하여 효율적으로 사용 가능
    - 프로세스의 경우, 오직 공유 메모리나 메시지 패싱을 이용하여 자원 공유 가능
- 경제성 (Economy)
    - 프로세스를 새로 생성하는 비용보다 스레드를 새로 생성하는 것이 훨씬 저렴
    - Context Switching(문맥 교환)의 오버헤드 또한 스레드가 더 경제적
        - Solaris에서 프로세스 생성은 스레드 생성보다 30배 느리고, switching은 5배 느림
- 확장성 (Scalability)
    - 한 프로세스를 여러 프로세서에서 수행할 수 있어 훨씬 효율적
    - 싱글 스레드의 경우, 한 프로세스는 오직 한 프로세서에서만 수행 가능

# 다중 스레드 모델

## 유저 스레드와 커널 스레드

### 유저 스레드(User-level Thread)

- 커널 위에서 커널의 지원 없이 유저 수준의 스레드 라이브러리가 관리하는 스레드

### 커널 스레드(Kernal-level Thread)

- 커널이 지원하는 스레드 (운영체제에 의해 직접 지원되고 관리)

커널 스레드를 사용하면 안정적이지만, 유저 모드에서 커널 모드로 계속 바꿔줘야 하기에 성능이 저하된다.
반대로, 유저 스레드를 사용한다면 안정성은 떨어지지만 성능이 저하되지 않는다.

따라서, 사용자 스레드와 커널 스레드는 어떠한 연관 관계가 존재할 필요성이 있다.

## 사용자 스레드와 커널 스레드의 연관 관계

### 다대일 모델 (Many-to-One Model)

하나의 커널 스레드에 여러 유저 스레드를 연결하는 모델

- 유저 공간의 스레드 라이브러리를 통해 스레드가 관리되어 효율적
- 한번에 한 유저 스레드만 커널에 접근할 수 있기에 멀티 프로세서 시스템에서 병렬적인 수행 불가
- 한 유저 스레드의 시스템 콜로 인해 Block되면 프로세스 전체가 Block됨

### 일대일 모델 (One-to-One Model)

하나의 커널 스레드에 하나의 유저 스레드가 대응하는 모델

- 동시성을 높여줌
- 멀티 프로세서 시스템에서 동시에 여러 스레드를 수행할 수 있도록 함
- 유저 스레드를 늘리면 커널 스레드도 똑같이 늘어나는데, 커널 스레드의 생성은 오버헤드가 크기에 성능 저하가 발생할 수 있음

### 다대다 모델 (Many-to-Many Model)

여러 유저 스레드에 더 적거나 같은 수의 커널 스레드가 대응하는 모델

- 운영체제는 충분한 수의 커널 스레드를 만들 수 있으며, 커널 스레드의 구체적인 개수는 프로그램이나 작동 기기에 따라 다름
- 멀티 프로세서 시스템에서는 싱글 프로세서 시스템보다 더 많은 커널 스레드가 만들어짐
- 완전한 동시성은 아니지만, 다대일 모델에 비해 더 높은 동시성을 가짐
- 일대일 모델의 단점이었던 커널 스레드 생성의 오버헤드도 걱정할 필요 없음

### 두 수준 모델 (Two-level Model)

- 다대다 모델에서 확장된 개념
- 특정 유저 스레드를 위한 커널 스레드를 별도로 제공
- 점유율이 높아야 하는 유저 스레드를 더 빠르게 처리할 수 있음

# 스레드와 관련된 문제들 (Threading Issues)

멀티스레드 프로그램을 디자인할 때 고려해야 할 몇 가지의 문제점이 존재한다.

## Semantics of fork() and exec() system calls

fork()는 해당 프로세스를 똑같이 복제하는 시스템 콜이다.
하지만, 멀티 스레드 환경에서 하나의 스레드에서만 fork()를 호출한다면 새 프로세스는 fork를 요청한 스레드만을 가진, 단일 스레드 프로세스여야 하는 것일까? 아니면 모든 스레드가 포함된 전체 프로세스를 복제해야 하는 것일까?

그 문제에 대해, 몇몇 UNIX 시스템은 두 가지 버전의 fork()를 가진다. (모든 스레드 복사/호출한 스레드만 복사)

## Signal Handling (신호 처리)

시그널은 UNIX 시스템에서 특정한 사건이 발생했다고 프로세스에게 알려주기 위해 사용하는 것이다.
자원이나, 시그널의 원인에 따라 두 종류로 나뉜다.

1. Synchronous Signals (동기식 시그널)
    - 시그널을 일으킨 작업을 수행한 프로세스에 전달 (ex. 0으로 나누기, 불법적인 메모리 접근)
2. Asynchronous Signals (비동기식 시그널)
    - 수행 중인 프로세스의 외부 사건에 의해 만들어짐 (ex. Ctl+C와 같은 특정 키 입력으로 인한 종료, 타이머 종료)

그러면 이런 신호(시그널)가 발생하면 처리를 해야 한다.

- 디폴트 신호 처리기: 모든 신호마다 커널이 실행
- 사용자 정의 처리기: 신호를 처리하기 위해 호출

이 두 가지 중 하나로 처리된다.
그리고 이러한 신호들을 전달하는 방법 또한 여러 가지 존재하는데, 신호의 유형에 따라 다르다.

단일 스레드 프로그램에서는 그냥 프로세스에게 전달만 하면 알아서 다룰 수 있다.

멀티 스레드 프로그램에서는 시그널을 제공한 스레드로 전달이 되거나 (ex. Synchronous signals), 프로세스 내의 모든 스레드에 전달되거나 (ex. process termination signal), 프로세스 내의 특정한 스레드에 전달될 수 있다(some asynchrounous singals to non-blocking threads).
혹은 프로세스의 모든 시그널을 전달받는 특별한 스레드를 할당받는 방법도 있다.

## Thread Cancellation (스레드 취소)

스레드가 끝나기 전에 종료시키는 방법에는 두 가지가 존재한다.

- Asynchrounous Cancellation(비동기식 취소): 목표 스레드를  즉시 종료시킴
- Deferred Cancellation(지연 취소): 목표 스레드가 종료되어야 하는지 주기적으로 체크한다.
    - 목표 스레드가 질서정연하게 강제 종료될 수 있는 기회가 만들어진다.

⇒ 디폴트 취소 유형은 지연 취소이다 (스레드가 취소점에 도달했을 때만 취소 작업이 일어나게 됨)

## Thread Pools

스레드를 요청할 대마다 매번 새로운 스레드를 생성, 수행, 삭제를 반복하면 성능이 저하된다.
따라서 미리 스레드 풀에 여러 스레드를 만들어 두고, 요청이 오면 스레드 풀에 기존에 존재하던 스레드를 할당하는 방법을 사용한다.

새 스레드를 만드는 것보다 기존에 존재하는 스레드를 사용하는 것이 약간 더 빠르고, 많은 양의 스레드를 일정한 크기의 pool 안에 묶어둘 수 있다는 장점이 있다.

## Thread Local Storage (스레드 로컬 저장소, TLS)

각각의 스레드들이 자신만의 독립적인 영역을 만들어 관리할 수 있도록 한다.

TLS와 지역 변수와 혼동하기에 쉽지만, 지역 변수는 하나의 함수가 호출되는 동안만 접근할 수 있는 반면 TLS는 함수 호출 전후에도 접근할 수 있다.
스레드가 존재하는 동안, 각 스레드에서만 접근할 수 있지만, 함수 호출 스코프를 벗어나, 스레드가 존재하는 동안 유지되는 데이터라는 점에서 정적 변수와 유사한 부분이 있다고 볼 수도 있다.

전역/정적 변수이지만 특정 스레드 안에서만 사용할 수 있는 데이터가 TLS라고 보면 될 것같다.

# 참고자료

[Operating System Concepts 에센셜 - 2판, Abraham Silberschatz, Peter Baer Galvin, Greg Gagne]

[혼자 공부하는 컴퓨터 구조 + 운영체제, 강민철]

https://brunch.co.kr/@kd4/3

https://inpa.tistory.com/entry/%F0%9F%91%A9%E2%80%8D%F0%9F%92%BB-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%E2%9A%94%EF%B8%8F-%EC%93%B0%EB%A0%88%EB%93%9C-%EC%B0%A8%EC%9D%B4#%EC%8A%A4%EB%A0%88%EB%93%9C

https://jerryjerryjerry.tistory.com/184

https://rebro.kr/174
