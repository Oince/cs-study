# 프로세스와 스레드

## 1. 프로그램(Program)

저장장치에 있는 **정적인 코드 덩어리**(실행 파일). 실행되려면 OS가 메모리·자원을 할당해야 함.

### 빌드 과정

- **전처리(Preprocessing)**: 주석 제거, 헤더파일 병합, 매크로 치환.
- **컴파일(Compile)**: 오류 처리·코드 최적화 후 **어셈블리어** 생성.
- **어셈블(Assemble)**: 어셈블리어 → **목적 코드(obj)**.
- **링크(Link)**: 프로그램 내 라이브러리 함수 또는 다른 파일들과 목적 코드를 결합 → **실행 파일** 생성.
    - **정적 라이브러리**
        - 라이브러리 코드가 실행 파일에 **붙는 방식**
        - 장점: 외부의존도가 낮다
        - 단점: 메모리 효율성이 떨어진다
    - **동적 라이브러리(DLL/so)**
        - 실행 시 **필요할 때** DLL함수 정보를 통해 참조하여 라이브러리 사용
        - 장점: 메모리 효율↑
        - 단점: 외부 의존성↑

## 2. 프로세스(Process)

컴퓨터에서 실행되고 있는 프로그램(동적인 상태)

CPU스케줄링의 대상이 되는 작업

프로그램이 메모리에 올라가 인스턴스화된 것

**독립 주소 공간**(코드/데이터/힙/스택)과 자원을 가짐.

서로 다른 프로세스는 메모리 직접 공유 X → **IPC**로 통신.

생성 시 OS가 자원 새로 할당 → **전환 비용 큼(컨텍스트 스위칭 무거움)**.

## 3. 프로세스 상태

- 생성
    - 이때 PCB를 할당 받는다
    - 메모리에 올라와 실행 준비 완료한 상태
- 대기
    - 메모리 공간이 충분하면 메모리 할당받고 아니면 대기하고 있으며 CPU스케줄러로부터 CPU소유권이 넘어오기를 기다리는 상태
- 대기 중단
    - 메모리 부족으로 일시 중단
- 실행
    - CPU소유권과 메모리를 할당 받고 인스트럭션을 수행중인 상태를 의미
    - CPU burst가 일어났다고 표현
- 중단
    - 이벤트가 발생 후 기다리며 프로세스가 차단된 상태
    - I/O디바이스에 의한 인터럽트로 이런 현상이 많이 발생
- 일시 중단
    - 중단된상태에서 프로세스가 실행되려고 했지만 메모리 부족으로 일시중단
- 종료
    - 메모리와 CPU소유권을 모두 놓고 가는 상태
    - 종료는 자연스럽게 종료되는것 혹은 부모 프로세스가 자식 프로세스를 강제 시키는 비자발적 종료도 있음.
    - 자식 프로세스에 할당된 자원의 한계치를 넘어서거나 부모프로세스가 종료되거나 사용자가 명령어로 프로세스 종료할 때 발생

## 4. 프로세스 상태(State) & 전이
<img width="542" height="210" alt="Image" src="https://github.com/user-attachments/assets/74d318c1-959c-4fb6-886c-51df63e28652" />

1. **Admitted**: New → Ready 프로세스 생성 승인 받음
2. **Dispatch**: Ready → Running 준비상태 프로세스들 중 하나가 스케줄러에 의해 실행
3. **Interrupt**: Running → Ready 예기치 않은 이벤트가 발생하여 준비상태로 전환하고 해당 작업 먼저 처리
4. **I/O or Event wait**: Running → Waiting 실행중 프로세스가 입출력이나 이벤트를 처리해야하면 입출력이나 이벤트가 끝날때까지 대기상태로 전환
5. **I/O complete**: Waiting → Ready 입출력이나 이벤트가 모두 끝난 프로세스를 다시 준비상태로 만들어 스케줄러에 의해 선택될수있는 상태로 전환

## 5. 프로세스 메모리 구조
프로세스가 만들어지면 4가지 영역으로 구성되어 할당 받게됨
<img width="471" height="708" alt="Image" src="https://github.com/user-attachments/assets/6361982f-e448-44a2-88d3-ccc8bcddb403" />
- 데이터 영역과 코드 영역
    - 정적 할당 영역 : 컴파일 단계에서 메모리를 할당하는 것
    - **Text(Code)**: 기계어 코드.
    - **Data**: BSS segment, Data segment, code/text segment로 나눠져 저장
        - **BSS**: **0 또는 미초기화 전역/정적 변수**.
        - Data: **0 이 아닌 초기화된 변수 또는 정적 변수**.
- 스택과 힙
    - 동적 할당 영역: 런타임 단계에서 메모리 할당 받음
    - **Heap**: 동적으로 할당되는 변수 담음. 동적으로 관리되는 자료구조 경우 힙 영역 사용
    - **Stack**
        - 지역변수, 매개변수, 실행되는 함수에 의해 늘어나거나 줄어드는 메모리 영역
        - 함수가 호출될 때 환경 등 특정 정보가 스택에 저장→함수 호출이 완료되면 소멸
        - 스택 영역 초과하면 stack overflow발생
## 6. PCB(Process Control Block)

- 프로세스 제어 블록
- 컨텍스트 스위칭할 때 프로세스 상태를 저장해둬야 다음에 작업을 이어서할수있음이를 위해, PCB는 프로세스 스케줄링을 위해 프로세스에 관한 모든 정보 저장하는 임시 저장소
- 프로세스의 중요한 정보를 포함하고 있어 일반 사용자가 접근하지 못하도록 커널스택의 가장 앞부분에서 관리
- 이 정보로 프로세스의 상태를 파악하고 우선순위를 조정하며 스케줄링 수행하고 다른 프로세스와 동기화 제어
- **종료**: 프로세스가 끝나면 PCB 폐기
<img width="556" height="300" alt="Image" src="https://github.com/user-attachments/assets/4241a200-96f5-4307-b41b-c545a8ec1324" />

-  **포함 정보**
    - 프로세스 스케줄링 상태: 프로세스의 상태(생성 준비 실행 대기 종료)
    - 프로세스 ID(PID): 프로세스 ID, 해당 프로세스의 자식 프로세스 ID, 프로세스 구분하는 구분자
    - 메모리 관련 정보: 메모리의 위치 정보, 메모리 보호를 위한 경계/한계레지스터
    - 프로세스 권한: 컴퓨터 자원 또는 IO디바이스에 대한 권한 정보
    - 프로그램 카운터: 프로세스에서 실행해야할 다음 명령어의 주소에 대한 포인터
    - CPU레지스터: 프로세스를 실행하기 위해 저장해야할 레지스터에 대한 정보
    - CPU스케줄링 정보: CPU스케줄러에 의해 중단된 시간 등에 대한 정보
    - 계정 정보: 프로세스 실행에 사용된 CPU사용량 , 실행한 유저의 정보
    - I/O상태 정보: 프로세스에 할당된 I/O디바이스 목록
    - 포인터: 프로세스의 현재 위치 저장

## 7. 컨텍스트 스위칭

- **정의**
    - PCB기반 프로세스의 상태를 저장하고 로드 시키는 과정
    - 한 프로세스에 할당된 시간이 끝나거나 인터럽트에 의해 발생
    - 실행되고 있는 프로세스는 한개이며 많은 프로세스가 동시에 운영되는 것처럼 보이는 건 다른 프로세스와 컨텍스트 스위칭이 아주 빠른 속도록 실행되기 때문
- 컨택스트 스위칭이 발생할 때 유휴시간이 발생(오버헤드)
    - PCB저장 및 복원 비용
    - 프로세스 자체가 교체되니 CPU캐시 메모리에 저장된 데이터가 무효화됨.
    - 메모리 접근 시간이 늘어나고 성능저하 발생
    - CPU스케줄링 알고리즘에 따라 프로세스를 선택하는 비용
- 컨텍스트 스위칭에 드는 비용
    - 캐시미스: 컨텍스트 스위칭 발생할 때 프로세스가 가지고 있는 메모리 주소가 그대로 있으면 잘못된 주소 변환이 생기므로 캐시 클리어 과정 진행
- **cf)스레드에서 컨텍스트 스위칭**
    - 스레드는 스택영역을 제외한 모든 메모리를 공유하기 때문에 비용이 더 적고 시간도 적게 걸림
    - 과하게 오버헤드 발생하면 멀티스레드가 싱글스레드보다 성능떨어질수있음
    - 캐시메모리 초기화 하지 않음
- 과정
    - CPU는 프로세스1(P1)실행
    - 인터럽트 혹은 시스템 콜 발생
    - 현재 실행중인 P1을 PCB1에 저장
    - 다음 실행할 P2선택(CPU스케줄링)
    - P2의 상태를 PCB2에서 가져옴
    - P2실행
    - 인터럽트 혹은 시스템 콜 발생
    - 현재 실행중인 P2을 PCB2에 저장
    - P1차례(CPU스케줄링)
    - P1의 상태를 PCB1에서 가져옴
    - P1중간 시점부터 실행
 
## 8. 멀티프로세싱

- 여러 프로세스로 병렬 처리(안정성↑, 통신비용↑).
- 특정 프로세스의 메모리, 프로세스 중 일부에 문제가 발생하더라도 다른 프로세스를 이용하여 처리→ 신뢰성 높음
- 각 프로세스는 독립적인 메모리 공간으로 안정성 높지만 통신이 복잡하고 비용 많이듬

## 9. IPC (프로세스 간 통신)

- 프로세스끼리 데이터를 주고받고 공유 데이터를 관리하는 메커니즘
- 메모리가 완전히 공유되는 스레드 보다 속도가 떨어짐
- CPU레지스터 교체 뿐 만아니라 캐시메모리까지 초기화 되기 때문에 자원부담이 크다
- 그래서 다중 작업이 필요한 경우 스레드를 이용하는 것이 효율적이다
- 따라서, 다중 프로세싱을 지원하지만 다중 스레딩을 기본으로 하고 있다
- 기법
    - **공유 메모리**
        - 여러 프로세스에 동일한 메모리 블록에 대한 접근 권한 부여되어 프로세스가 서로 통신
        - 메모리 자체를 공유하기 때문에 불필요한 데이터 복사의 오버헤드가 발생하지 않음
        - 가장 빠름. 동기화 필요.
    - **파이프**:
      - 추가의 메모리 공간을 할당하여 데이터를 주고받을 수 있도록함
      - 단방향으로 하나의 프로세스는 데이터 쓰기만 다른건 읽기만 함.
      - **익명 파이프**: **부모-자식 프로세스에서 사용,**데이터 통신을 할 프로세스가 명확한 경우에 사용, 부모 프로세스IP를 통해 파이프 접근
      - **명명된 파이프(named pipe)**: 클라이언트 서버 통신을 위한 별도의 파이프를 제공하며 여러 파이프를 동시에 사용할 수 있음. 컴퓨터의 프로세스 끼리 또는 다른 네트워크 상 컴퓨터와도 통신, 독립된 프로세스간 통신할때 사용,파일을 통해 통신

  - **메시지 큐**: 커널이 큐로 관리, 직관적, 다중 프로세스 간 통신 지원, 메모리 공간에서 통신 이루어짐, 비동기 통신이 가능, 식별자에 의해 데이터들이 식별되어 여러 프로세스가 동시에 원하는 데이터로 접근 가능, 메시지 전달 마다 운영체제가 개입하니 높은 커널 의존성을 가지며 속도가 낮아짐, 자원에 대한 동기화 문제는 발생하지 않음

  - **소켓**
    - 동일한 컴퓨터의 다른 프로세스나 네트워크의 다른 컴퓨터로 네트워크 인터페이스를 통해 전송하는 데이터
    - TCP/UDP
  - **파일**
    - 디스크에 저장된 데이터 혹은 파일 서버에서 제공한 데이터로 프로세스간 통신
    - 느리지만 단순/지속성.

## 10. 스레드(Thread)

프로세스 내 **실행 흐름의 최소 단위**. 

프로세스는 여러 스레드 가질 수 있음.

스레드간 통신: 메모리 공유

**프로세스 자원 공유 : 코드/데이터/힙을 공유**하고, **각자 스택·레지스터(컨텍스트)만 독립**.

- 전환 비용이 **프로세스보다 훨씬 작음**(동일 주소 공간 → TLB/캐시 영향 적음).
- 한 스레드 오류가 프로세스 전체에 영향 가능(안정성 유의).
- 별도의 스택을 갖고있기 때문에 독립적인 함수 호출이 가능하다→독립적인 실행흐름이 추가된다는 말→자원의 생성,관리의 중복성을 최소화하여 수행능력 향상

상태
- NEW: 스레드가 생성되고 아직 호출되지 않은 상태
- RUNNABLE: 스레드 실행되기 위해 기다리는 상태, CPU를 할당 받을 수 있는 상태이며 언제든 실행될 준비 되어있음
- BLOCKED: 스레드가 특정 이벤트가 발생하여 대기하는 상태, CPU를 할당받지 못하며 다시 RUNNABLE상태로 전환될때까지 대기
- TERMINATED: 스레드가 실행을 완료하고 종료된 상태, 메모리에서 제거
<img width="539" height="286" alt="Image" src="https://github.com/user-attachments/assets/33a1b03d-72a8-4cc1-b59f-2da7ca3b2620" />

## 11. 멀티스레딩

- 한 프로세스 내 다중 스레드
- 스레드끼리 서로 자원을 공유하기 때문에 효율성이 높음
- 동시성: 서로 독립적인 작업들을 작은 단위로 나눠 동시에 실행되는 것처럼 보여주는것
- 단점: 한 스레드에 문제가 생기면 다른 스레드에도 영향
- 스레드 스케줄링
    - 다중 스레드 관리
    - 우선순위, 실행시간, 입출력 등 정보를 고려하여 CPU가 사용할 수 있는 스레드 선택하고 CPU할당
    - 하나의 프로세스 내 다수의 스레드가 동작하니 스레드 간 상호작용과 동기화 문제를 고려

## 12. TCB

스레드 제어블록

PCB안에 들어있음

스레드 상태정보, 스레드 IP, 우선순위 등 저장

스레드가 생성될때 OS의해 생성되며 스레드 실행 끝나면 소멸될떄 같이 소멸

스레드간 자원 고유와 동기화 진행할떄 정보 관리

PCB보다 가볍다.

## 13. 공유자원

시스템 안에서 각 프로세스, 스레드가 함께 접근할 수 있는 자원이나 변수 등 의미

이 공유 자원을 두 개 이상의 프로세스가 동시에 읽거나 쓰는 상황을 경쟁상태라고 함

## 14. 임계 영역

- 공유자원에 동시 접근 시 결과가 달라지는 코드 영역.
- 상호배제: 한 프로세스가 임계영역에 들어가면 아무도 들어올수없음
- 한정대기:한 프로세스가 영원히 임계영역에 못 들어가면 안됨
- 융통성: 아무도 임계영역에 안 들어가면 외부 어떠한 프로세스도 들어갈수있으며 프로세스끼리 서로 방해 안함
- **도구**
    - **뮤텍스**
        - 공유자원을 lock()을 통해 잠금 설정하고 사용한 후 unlock으로 잠금해제하는 객체
        - 잠금/잠금해제 상태만 가짐, 임계 구역에 1개의 스레드만 들어감
    - **세마포어**
        - 동시에 자원에 접근할수있는 프로세스
        - 간단한 정수 값과 wait(P함수-자신의 차례올때까지 기다리는 함수), signal(V함수-다음 프로세스로 순서를 넘겨주는 함수)로 경유자원에 대한 접근 처리
        - 공유 자원에 접근하면 세마포어에서 wait작업→공유자원해제하면 signal수행
        - 임계의 스레드에 여러 스레드 들어감
        - 바이너리 세마포어:0/1, 뮤텍스는 바이너리 세미포어라고 할 수있지만 잠금기반으로 상호 배제일어나는 잠금 메커니즘이고 세마포어는 신호 기반 상호배제가 일어나는 신호 메커니즘
        - 카운팅 세마포어: 여러 값을 가질 수있는 세마포어, 여러 자원에 대한 접근을 제어하는데 사용
    - **모니터**
        - 둘 이상의 스레드나 프로세스가 공유 자원에 안전하게 접근할 수 있도록 공유 자원을 숨기고 해당 접근에 대해 인터페이스만 제공
        - 모니터 큐를 통해 공유 자원에 대한 작업들을 순서대로 처리
        - 세마포어와 차이점: 모니터에서 상호배제는 자동인 반면에 세마포어에서 상호배제는 명시적으로 구현

## 11) 교착상태(Deadlock)

- 두개 이상의 프로세스들이 서로 가진 자원을 기다리며중단된 상태
- 원인
    - 상호배제: 한프로세스가 자원을 독점하고 있어 다른 프로세스들은 접근 불가능
    - 점유대기: 특정 프로세스가 점유한 자원을 다른 프로세스가 요청하는 상태
    - 비선점: 다른 프로세스의 자원을 강제적으로 가져올 수 없음
    - 환형대기: 서로가 서로의 자원을 요구하는 상황
- **대응**
    - 자원을 할당할때 애초에 조건이 성립되지 않도록 설계
    - 교착상태 가능성이 없을 때만 자원이 할당되며 프로세스 당 요청할 자원들의 최대치를 통해 자원 할당 가능 여부를 파악하는 은행원 알고리즘 사용
        - 은행원 알고리즘: 총 자원의 양과 현재 할당한 자원의 양을 기준으로 안정 불안정상태로 나누고 안정상태로 가도록 하는 자원할당 알고리즘
    - 교착상태가 발생하면 사이클이 있는지 찾아보고 관련된 프로세스를 한개씩 지움
    - 해결하는 비용이 커서 사용자가 작업을 종료.(ex)응답없음
 
## 예상질문
Q1. 프로그램/프로세스/스레드 차이?
A1. 프로그램: 정적 코드. 프로세스: 실행 인스턴스(독립 주소 공간). 스레드: 프로세스 내 실행 흐름(코드/데이터/힙 공유, 스택만 독립).
Q2. 프로세스 메모리 4영역?
A2.Text, Data(초기화 전역/정적), BSS(미초기화/0), Heap, Stack.
Q3.PCB에는 무엇이 들어있나?
A3.PID, 상태, 레지스터/PC, 스케줄링 정보, 메모리 맵/보호, 파일·I/O 등.
Q4.뮤텍스/세마포어/모니터 차이?
A4.뮤텍스: 1개 진입 Lock. 세마포어: 카운트 기반 신호. 모니터: 언어/런타임이 상호배제 자동 + 조건 변수 제공.
