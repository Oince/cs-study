# CPU스케줄링과 알고리즘

## 1) CPU 스케줄러란?

CPU스케줄링 알고리즘으로 프로세스에서 해야하는 일을 스레드 단위로 CPU에 할당

## 2) 스케줄링 단계 (용어 정리)

- **고수준(장기, Long-term) 스케줄링**
    - 시스템에 **새 작업을 받아들일지** 결정 → 시스템 내 **동시 활성 프로세스 수** 조절.
- **중간 수준(Medium-term) 스케줄링**
    - 프로세스가 활성화된 후에도 여러 가지 사정으로 시스템에 과부하가 걸릴 수 있다. 이를 방지하기 위해 중지(suspend)와 활성화(active)로 전체 시스템의 활성화된 프로세스 수를 조정하여 과부하를 막는다. 이때, 이미 활성화된 프로세스 중 일부를 보류 상태로 보낸다.
- **저수준(단기, Short-term) 스케줄링**
    - 활성화된 프로세스를 준비 상태로 보낼지, 실행 상태로 보낼지, 대기 상태로 보낼지 결정하는 것이다
    - 사실상 실제로 작업이 이루어지는 스케줄링이라고 볼 수 있다.
## 3) 스케줄링 목적

- **공평성**: 모든 프로세스가 자원을 공평하게 배정받음
- **효율성**: 유휴시간 최소화, 전체 처리량 극대화
- **안정성**: 중요 작업 보호(우선순위), 오동작 격리
- **확장성** 작업 수 증가에도 시스템이 안정적으로 작동하도록 조치
- **반응 시간** 보장: 시스템은 적절한 시간 안에 프로세스의 요구에 반응
- **기아 방지**: 특정 프로세스의 작업이 무한히 연기되어서는 안 된다.

## 4) 주요 시간 지표

- **대기 시간(Waiting time)**: 준비 큐에 도착 후 실행되기 전까지 대기하는 시간
- **응답 시간(Response time)**: 첫 작업을 시작한 후 첫 번째 실행(반응)이 나오기까지 걸리는 시간
- **실행 시간(CPU burst/Service time)**: 프로세스 작업이 시작된 후 종료되기까지 걸리는 시간
- **반환 시간(Turnaround time)**: 대기 시간을 포함하여 실행이 종료될 때까지 걸리는 시간, 즉 프로세스의 준비 큐 도착부터 종료까지 걸리는 시간
## 5) 비선점형(Non-preemptive) 알고리즘

프로세스가 스스로 CPU소유권을 포기하는 방식, 강제로 프로세스를 중지하지 않음, 컨텍스트 스위칭으로 인한 부하가 작음

### ● FCFS (First-Come, First-Served)

- 도착 순서대로 실행.
- 길게 수행되는 프로세스 때문에 준비 큐에서 오래기다리는 현상 발생
<img width="553" height="392" alt="Image" src="https://github.com/user-attachments/assets/8237c0b9-3c7b-4b3f-a333-5bb74dec97b8" />

### ● SJF (Shortest Job First)

- **예상 실행 시간**이 가장 짧은 작업 우선.
- 평균대기시간이 가장 짧지만 실제로 실행시간을 알수없기 때문에 과거 실행했던 시간을 토대로 추측해서 사용
- 긴 시간 필요하는 프로세스 우선순위가 밀려 무기한 대기하는 기아현상 발생가능
<img width="543" height="435" alt="Image" src="https://github.com/user-attachments/assets/57bb7382-feda-432c-8156-57cf27ec4577" />

### ● 우선순위 스케줄링

- SJF스케줄링의 경우 긴 시간을 가진 프로세스가 실행되지 않는 현상있었음
- 오래된 작업일 수록 우선순위를 높이는 방법을 사용해 보완한 알고리즘.
- FCFS를 활용해 만들기도하며 선점형 비선점형적인 우선순위 스케줄링 알고리즘을 말하기도 함
<img width="565" height="405" alt="Image" src="https://github.com/user-attachments/assets/2735768d-e57b-4e33-8cf4-e8f97b02de17" />

## 6) 선점형(Preemptive) 알고리즘

현재쓰는 방식. 

지금 사용하고 있는 프로세스를 알고리즘에 의해 중단시키고 강제로 다른 프로세스에 CPU소유권 할당하는 방식

잦은 컨텍스트 스위칭으로 오버헤드 커질수있음

### ● 라운드 로빈(Round Robin)

- 각 프로세스는 동일한 할당 시간을 주고 그 시간안에 끝나지 않으면 다시 준비 큐의 뒤로 가는 알고리즘
- 할당시간이 너무 크면 FCFS가 되고 짧으면 컨텍스트 스위칭이 잦아져 오버헤드 비용이 커짐.
- 전체 작업 시간은 길어지지만 평균 응답 시간은 짧아진다는 특징
- 로드 밸런서에서 트래픽 분산 알고리즘으로도 쓰임
<img width="548" height="360" alt="Image" src="https://github.com/user-attachments/assets/699445e4-7cc9-4e20-8a90-5574120d0e4b" />

### ● SRF

- 중간에 더 짧은 작업이 들어오면 수행하던 프로세스를 중지하고 해당 프로세스를 수행하는 알고리즘
- 평균 대기 시간을 줄일 수 있지만 다음 프로세스의 CPU burst time을 예측하는 것이 어렵다는 문제
<img width="539" height="379" alt="Image" src="https://github.com/user-attachments/assets/f2c16d54-b966-4d60-af5b-752d0915d723" />

### ● 다단계 큐(Multilevel Queue)

- 우선순위에 따른 준비 큐를 여러 개 사용하고 큐마다 라운드로빈이나 다른 스케줄링 알고리즘을 적용한것
- 큐간 프로세스 이동이 안되므로 스케줄링 부담이 적지만 유연성이 떨어지는 특징
- 우선순위가 높은 큐부터 처리되기 때문에 낮은 큐의 프로세스가 처리가 안되는 기아(Starvation)현상이 나타날 수도 있으며, 각 큐 사이에서 프로세스들이 이동할 수 없어서 유연성이 떨어지는 특징이 있다.
<img width="571" height="342" alt="Image" src="https://github.com/user-attachments/assets/4652c1f3-a813-41dc-b61d-60ee20a29453" />

## 예상질문
FCFS의 단점은?
→ 긴 작업 뒤에 짧은 작업이 오게되면 준비 큐에서 오래 기다리는 현상

라운드 로빈 할당시간 기준 영향?
→ 너무 크면 FCFS, 너무 작으면 스위칭 오버헤드↑. 응답성↔오버헤드 균형이 핵심.

응답 시간·반환 시간·대기 시간 정의?
→ 응답: 도착→첫 실행, 반환: 도착→종료, 대기: Ready 큐에서 기다린 누적 시간.
