# CPU 스케줄링

운영체제가 프로세스에게 공정하고, 합리적으로 CPU 자원을 배분하는 것.
결론적으로는 시스템의 성능 향상을 위함이다.

어떻게 자원을 분배해야 성능을 극대화하고, CPU 효율을 극대화할 수 있을 지를 고민하는 것이다.

- CPU 활용 극대화
- 프로세스 처리율(시간 당 작업량)을 늘릴 수 있다

프로세스는 필요한 자원을 할당받기 위해 큐에 대기하는데, 이 큐에 있는 프로세스를 어떻게 스케줄링 할 지에 대한 규칙을 스케줄링 알고리즘이라고 한다.

## 그런데 언제 스케줄링을 수행하지?

CPU 스케줄링 결정은 다음 네 가지의 상태 변환에서 발생한다

1. running → waiting: I/O 작업 요청 등으로 wait() 하는 상황
2. runnig → ready: 인터럽트 발생 시
3. waiting → ready: I/O 작업 종료
4. terminated: 프로세스 종료

1번과 4번 상황 같이 프로세스가 메모리에서 내려가는 상황에서는
반드시 새 프로세스를 선택해야 하기 때문에 이미 실행 중인 프로세스가 CPU를 계속 가지고 있을 수 없다.
이처럼 CPU 자원을 중간에 빼앗지 않는 방식을 비선점 스케줄링(Non-preemptive scheduling)이라고 한다.

반대로, 2번과 3번 상황에서는 다른 프로세스가 현재 실행 중인 프로세스를 강제로 중단하고 CPU를 가져갈 수 있다. 다른 프로세스가 자원을 선점할 수 있는 선택의 여지가 있다는 의미이며, 자원 경쟁이 발생할 수 있다.
이처럼 CPU 자원을 중간에 빼앗을 수 있는 방식을 선점 스케줄링(Preemptive scheduling)이라고 한다.

이와 같이 스케줄러가 준비 큐에서 실행할 다음 프로세스를 선택하고 나면, 디스패처가 문맥 교환, 유저 모드로의 전환, PC 이동(Program Counter Jump) 등의 자원 관리를 맡는다.

# 스케줄링 알고리즘

CPU 스케줄링의 목적은 대기 시간을 줄이는 것이다. (CPU를 최대한 바쁘게 유지하는 것)
따라서, 상황에 따라 알맞는 CPU 스케줄링 알고리즘을 사용해야 한다.

다양한 알고리즘들이 존재하지만 가장 많이 나오는, FIFO(FCFS), SJF, Priority, RR 정도를 다뤄보도록 하겠다.

## First-Come, First-Served (FCFS) / 비선점형

> 선입 선처리 스케줄링
> 

CPU를 먼저 요청하는 프로세스가 CPU를 먼저 할당받는 것

- 먼저 요청하면 먼저 실행할 수 있다!
- 만약 실행시간이 긴 프로세스가 앞 순서에 몰린다면, 평균 대기 시간이 매우 길어질 가능성이 있다

## Shortest-Job-First (SJF) / 비선점형

> 최소 잔여 시간 우선 스케줄링 / 최단 작업 우선 스케줄링
> 

CPU burst time을 기준으로 가장 짧은 시간을 가진 프로세스를 스케줄링

- 실행 시간이 낮은 프로세스부터 실행하기에 평균 대기 시간이 매우 단축되는 이상적인 스케줄링 방식
- 이론적으로 가장 최적화된 스케줄링 알고리즘이지만, 실현 가능성이 낮은 알고리즘
    - 프로세스를 실행하기도 전에 프로세스의 실행 시간을 알 수 없다는 점 등
- 두 프로세스가 동일한 길이의 burst time을 가지면, 선입선출로 순서 정함

## Shortest-Remaining-Time-First (SRTF) / 선점형

CPU burst time을 기준으로 가장 짧은 시간을 가진 프로세스를 스케줄링
하지만, 잔여 작업이 더 적게 남아 있는 프로세스가 새로 들어오면 그 프로세스에게 자원을 우선 할당해 줌

## Round Robin (RR) / 선점형

> 라운드 로빈
> 

CPU 자원을 Quantum 시간에 따라 공평하게 나누어, 도착한 순서대로 정해진 Quantum만큼의 시간만 실행하는 것을 반복

- 시분할 시스템을 위해 설계
- quantum 시간이 짧을 수록 문맥 교환이 많이 일어나기에 오버헤드는 증가하고 효율이 떨어지며, 평균 대기 시간은 매우 길어질 수 있다.
(보통 10ms < q < 100ms로 시간 할당량을 가지고 있음)
- CPU 버스트의 80%는 시간 할당량보다 짧아야 한다
- SJF보다 총 처리 시간은 크지만, 응답 시간은 더 좋다 (시분할 시스템에서 더 좋음)

## Priority (우선 순위) / 선점형, 비선점형

가장 높은 우선 순위를 가진 프로세스에게 CPU 자원을 할당하는 것.

- 우선 순위가 같은 프로세스들은 FCFS로 스케줄링됨
- 우선 순위는 일정 범위의 수가 사용됨
    - 0이 최상위인지, 최하위인지 일반적으로 합의되어 있지 않음
    - 우선 순위는 내부/외부적으로 정의될 수 있음
- 선점형 또는 비선점형이 될 수 있다
- SJF 알고리즘 또한 우선순위 스케줄링 알고리즘의 한 경우: CPU 버스트가 클수록 우선순위가 낮고, 그 역도 성립
- 우선 순위 알고리즘의 주요 문제
    - 무한 봉쇄(Indefinite Blocking)
        - 실행 준비는 되어 있으나, CPU 자원 할당을 무한히 대기하는 프로세스의 경우, 봉쇄된 것으로 간주 가능
        - 낮은 우선순위 프로세스들이 CPU를 무한히 대기하는 경우 발생
    - 기아 상태(Starvation)
        - 낮은 우선순위의 프로세스들이 무한히 봉쇄됨 (실행되지 않음)
    
    ⇒ 해결 방안: 노화 (aging)
    
    - 일정한 시간마다 프로세스의 우선 순위를 증가시킴
    - 오랫동안 시스템에서 대기하는 프로세스들의 우선순위를 점진적으로 증가시킴

# 참고자료

[Operating System Concepts 에센셜 - 2판, Abraham Silberschatz, Peter Baer Galvin, Greg Gagne]

https://reakwon.tistory.com/132

https://pom-pomm.tistory.com/20

https://blog.naver.com/ds4ouj/222648147304
