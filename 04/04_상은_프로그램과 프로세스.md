# 프로그램
> 실행 가능한 파일
> 
- 컴퓨터에서 어떤 작업을 위해 실행할 수 있는 `정적인 상태` 의 파일
- 특정 목적(작업)을 수행하기 위한 명령문들의 집합
- 디스크에 저장되어 있는 실행 가능한 파일 또는 스크립트

# 프로세스
> **실행 중인 프로그램**
> 
- 컴퓨터에서 연속적으로 실행되고 있는 `동적인 상태`의 컴퓨터 프로그램
- 프로그램을 실행하면, 운영체제로부터 실행에 필요한 자원을 할당 받아 `프로세스`가 되는 것
    - CPU 시간
    - 운영되기 위해 필요한 주소 공간
    - 독립된 메모리 영역 (Code/Data/Stack/Heap 영역으로 이루어짐)
- 디스크 안에 있는 프로그램을 메모리로 가져와서 실행 중인 프로그램
- 메모리에 올라가 있는 프로그램
- 프로세스의 종류
    - 포그라운드 프로세스(foreground process): 사용자가 보는 앞에서 실행되는 프로세스
    - 백그라운드 프로세스(background process): 사용자가 보지 못하는 뒤에서 실행되는 프로세스
        - 그 중, 사용자와 직접 상호작용 하지 않고, 정해진 일만 수행하는 프로세스가 존재
            
            ⇒ 데몬(Daemon) / 서비스(Service)
            
            ➕ Docker 컨테이너에서 최초로 실행되는 프로세스 (PID 1)이 데몬 역할을 한다!
            

➕ 프로세스는 최소 하나 이상의 스레드를 포함한다.

- 한 프로세스는 다른 프로세스의 변수나 자료 구조에 접근할 수 없으며, 접근을 위해서는 IPC 통신이 필요
    - 파이프, 파일, 소켓을 이용한 통신 방법 이용

### ☝ 프로그램과 프로세스는 일대다(1:N) 매핑이 가능하다.

- `파이어폭스`라는 프로그램이 존재 (1)
    - `파이어폭스`프로그램을 여러 개 실행시킴 (N)

⇒ 프로그램은 하나지만, 그 프로그램을 실행시킨 프로세스는 여러 개가 실행될 수 있음

<img width="1133" height="367" alt="image" src="https://github.com/user-attachments/assets/cc2b3b89-f7a8-42eb-a3b1-f577dda387a2" />
이런 식으로 현재 실행 중인 프로그램들을 프로세스라고 한다 (탭을 여러 개 열어두니, 프로세스도 여러 개 실행되고 있는 것을 알 수 있다)

# 프로세스 메모리의 구조
> 프로세스가 메모리로 로딩될 때, 스택/힙/데이터/텍스트(코드) 영역으로 나뉘어 로딩된다.
> 

<img width="1091" height="1483" alt="image" src="https://github.com/user-attachments/assets/1ccdbab4-712b-4a7a-98e6-67087f19647b" />

### Code(Text) 영역
> 실행할 프로그램의 코드가 저장되는 읽기 전용 공간
> 

데이터가 아닌 CPU가 실행할 명령어들이 담겨있기에 쓰기가 금지되어 있음

### Data 영역
> 전역 변수와 정적 변수를 저장
> 

프로그램이 실행되는 동안 유지해야 할 데이터들이 저장되는 공간

- 프로그램이 시작될 때 할당되어 프로그램 종료 시 소멸됨
- Data 영역과 BSS(Block Stated Symbol) 영역
    
    ⇒ 초기값을 저장해야 할 필요가 있는 것과 아닌 것 구분
    
    - Data : 초기화 된 전역 변수와 정적 변수가 저장되는 공간
    - BSS: 초기화 되지 않은 전역 변수와 정적 변수가 저장되는 공간

### Heap 영역
> 동적 데이터 영역 (ex. malloc, new)
> 
- 메모리 주소 값에 의해서만 참조되고 사용되는 영역
- 프로그래머가 필요할 때마다 할당하는 공간
- 프로그램 동작 시(런타임)에 크기가 결정됨
    
    ⇒ 프로그래머가 직접 할당할 수 있는 저장 공간
    
- 낮은 주소에서 높은 주소로 할당 (FIFO)

### Stack 영역
> 매개 변수, 지역 변수, 리턴 값 등 잠시 사용되었다가 사라지는 데이터를 저장
> 
- 잠시 사용되었다가 사라지는 데이터를 저장하는 영역
- 데이터를 일시적으로 저장하는 공간
- 잠깐 쓰다가 말 값들이 저장되는 공간
- 높은 주소에서 낮은 주소로 할당 (LIFO)

# 프로세스 제어 블록 (PCB)
> 프로세스 상태 정보를 담고 있는 구조체
> 

프로세스 메모리 구조의 맨 위에 있던, 커널 영역에 존재하는 프로세스 제어 블록이다.

빠르게 번갈아 수행되는 프로세스의 실행 순서를 관리하고, 프로세스에 자원을 배분해야 함.
이를 위해 운영체제는 프로세스 제어 블록(PCB)를 이용하여 자원을 관리한다.

<img width="700" height="491" alt="image" src="https://github.com/user-attachments/assets/38d7d4e4-ecde-47cd-8f49-ca00bac6d28b" />

프로세스 테이블을 사용하여 각 프로세스의 PCB를 관리

- 커널 영역에 생성됨
- 운영체제가 프로세스를 제어하기 위한 정보를 저장해 놓은 곳
- 시스템 내의 프로세스들을 관리하기 위해 프로세스마다 유지하는 정보들을 담는 커널 내의 자료구조
- 프로세스 상태 관리와 문맥 교환을 위해 필요
- 프로세스 생성과 함께 만들어지며, 프로세스가 종료되면 폐기

## PCB에 저장되는 정보

운영체제마다 차이가 있지만, 주로 아래와 같은 정보들이 포함된다.

프로세스의 관리와 스케줄링을 효율적으로 수행하는 것이 목적이기에, 그에 관련된 정보들이 저장된다고 보면 된다.

- 프로세스 식별자(PID; Process ID): 프로세스를 식별하는 고유 번호 및 식별자
- 프로세스 상태(Process State): 현재 프로세스가 어떤 상태(new, ready, running, waiting, terminated)에 있는지 저장
- 프로그램 카운터(PC; Program Counter): 프로세스가 다음에 실행할 명령어의 주소를 가리키는 레지스터 값
- 레지스터 값(Registers): 프로세스의 레지스터 상태를 저장
    - 프로세스가 중단되거나 재개될 때, 이전에 진행하던 작업 상태를 복원시켜 계속 진행할 수 있도록 함
    - 해당 프로세스가 실행하며 사용했던 프로그램 카운터를 비롯한 레지스터 값들이 담김
- 우선 순위(Priority): 다중 작업 환경에서 프로세스에 할당되는 우선 순위
- CPU 스케줄링 정보: 프로세스가 언제, 어떤 순서로 CPU에 할당 받을 지에 대한 정보 (방식 및 시점)
- 메모리 관리 정보: 프로세스가 사용하는 메모리 영역에 대한 정보, 할당된 메모리의 위치 등 포함
- 입출력 상태 정보: 프로세스가 어떤 입출력 작업을 요청했는지, 해당 작업의 상태 등을 나타냄
- 자원 할당 정보(어카운팅 정보): 프로세스에 할당된 자원(메모리, 입출력 장치 등)에 대한 정보를 담음
    - 사용된 CPU 시간, 실행이 시작된 이후 경과된 시간(클럭 타임), 메모리, 입출력 등 자원 사용 기록

## 운영 체제와 PCB

- PCB는 운영 체제의 핵심 개념 중 하나로, 다중 작업 환경에서 프로세스를 효율적으로 관리하기 위해 필수적이다
- 운영체제는 PCB를 활용하여 CPU 스케줄링, 프로세스 상태 관리, 문맥 전환이나 자원 할당 등의 다양한 작업을 수행
- PCB를 통해 운영체제는 여러 프로세스를 조율하며 시스템의 안정성과 성능을 유지

# 프로세서의 프로세싱
> 프로세서(CPU)는 동시성과 병렬성을 지원한다.
> 

## 프로세스의 동시성

> 문맥 교환(Context Switching)을 통해 프로세스가 동시에 진행되는 것처럼 느끼게 한다.
> 

프로세서(CPU)는 원래 한 번에 하나의 프로세스만 실행시킬 수 있지만, 문맥 교환을 매우 빠른 속도로 반복하여 여러 프로세스가 동시에 진행되는 것처럼 느끼게 한다.

## 프로세서의 병렬성

> 코어를 여러 개 두어 각자 작업을 담당하도록 하여 실제로 동시에 프로세스가 진행되도록 한다.
> 

프로세서(CPU) 하나에 코어 여러 개가 달려서 각각 동시에 작업을 하는 방식

코어를 여러 개 담아 작업을 분담하도록 한다.

이는 반드시 듀얼코어, 쿼드코어 등의 명칭을 달고 있는 컴퓨터에서만 할 수 있다.

### 내 컴퓨터로 생각해보기

내 데스크탑의 CPU는 AMD Ryzen 9 7900X 12-Core Processor이다.

컴퓨터를 잘 모르는 사람을 위하여 컴퓨터 스펙을 노예로 비유한 사진이 많이 돌아다녔다.
거기서 코어의 수는 내가 부릴 노예의 수라고 설명을 했다.

따라서 나는 12명의 노예를 부리며, 12명의 코어에게 분담하여 작업하도록 하는 것이다.
그렇다면 작업이 8명의 코어를 부리는 것 보다 더 빠르게 작업이 수행될 수 있겠지? 또한, 어떤 코어가 아프다고 하더라도 다른 많은 코어들이 그 작업들을 분담하면 되니, 추가로 떠맡게 되는 업무도 상대적으로 적을 것이다.

물론 작업 특성이나, I/O, 소프트웨어의 병렬 처리 가능성 등 다양한 요소에 따라 성능은 달라질 수 있는 것이다.
(노예 비유법으로 하자면 일머리 좋은 친구가 있을 수도 있고, 일머리 없는 친구들이 있을 수도 있고, 갑자기 코어 중 몇몇이 차출되어 다른 농장일을 하러 갈 수도 있고… 하는 다양한 상황이 있을 수 있다고 보면 된다)

# 문맥 교환 (Context Switching)

> 이전 프로세스의 상태(문맥)을 보관하고 새로운 프로세스의 상태를 적재하는 작업
> 
- 한 프로세스의 문맥은 PCB에 기록되어 있음
    - 이러한 Context 정보를 활용하여 CPU를 선점하고 있던 프로세스는 자신의 문맥을 PCB에 저장하고, 새롭게 CPU를 할당받을 프로세스는 PCB로부터 예전에 저장되었던 자신의 문맥을 실제 하드웨어로 복원하는 과정을 거침
- 문맥 교환 중에는 CPU가 활동을 하지 않는 상태이기 때문에 오버헤드의 문제가 있다.
    - 많은 부담이 가는 활동이니 가능한 적게 일어나는 편이 좋다.
    - 주로 아래와 같은 행위에 의해 발생한다
        - PCB 저장 및 복원 비용
        - CPU 캐시 메모리 무효화에 따른 비용
        - 프로세스 스케줄링 비용
- 병행성 → CPU가 문맥 교환을 무수히 반복하면서 수많은 프로세스가 마치 동시에 실행되는 것처럼 보이는 것

## 문맥 교환의 시점

### 멀티 태스킹

> 프로세스들이 프로세서로부터 빠른 속도로 번갈아가며 자원을 할당받아 실행되며,
사용자가 느끼기에는 동시에 실행되는 것처럼 느껴지도록 하는 방법
> 
- 운영체제의 스케줄러에 의해 프로세스들이 짧은 시간마다 번갈아 수행됨
- CPU 할당 시 문맥 교환이 발생
- 매우 빠른 속도로 처리되기에 동시에 처리되는 것처럼 느껴짐

### 인터럽트 처리

> 컴퓨터 시스템에서 예외 상황이 발생했을 때, CPU에게 알려 처리할 수 있도록 하는 것
> 
- I/O Request: 입출력 요청
- Time Slice Expired:  CPU 사용 시간 만료
- Fork a Child: 자식 프로세스 생성
- Wait for an Interrupt: 인터럽트 처리 대기

### 사용자 및 커널 모드 전환

> OS에서 사용자 모드와 커널 모드 사이의 전환이 필요할 때, OS에 따라 문맥 교환 발생
> 

## 문맥 교환이 일어나는 과정

1. 요청 발생
2. PCB에 문맥 저장
    - 기존에 자원을 선점하고 있던(실행 중인) 프로세스의 정보를 PCB에 저장
    - 이후 다시 문맥 교환이 일어날 때 기존 프로세스의 정보(문맥)를 불러오기 위함
3. CPU 할당
    - 새로 자원을 선점 받을(실행 예정인) 프로세스의 정보(문맥)를 PCB에서 가져와 CPU 할당

# 프로세스의 생명 주기

프로세스는 생명 주기를 가지고 있다.

프로세스는 메모리에 올라가 실행되고 있는 프로그램을 의미한다.
그렇다는 말은, 필요하기에 실행되고 있지만 필요 없기에 메모리에서 그 프로세스를 내릴 수 있다는 것이다.

그것이 바로 생명 주기(lifecycle)이며, 운영체제는 이러한 생명 주기를 관리하고, 프로세스를 조정하며 시스템 자원을 효율적으로 사용할 수 있는 것이다.

일반적으로 프로세스 스케줄링과 프로세스 상태 관리를 통해 프로세스의 생명 주기가 관리된다.

## 프로세스 스케줄링

CPU라는 자원은 언제나 한정되어 있다. 따라서 운영체제는 CPU를 사용할 수 있는 프로세스를 선택하고 CPU를 할당하는 작업을 수행한다

프로세스의 우선순위, 작업량 등을 고려하여 효율적으로 배치한다. 운영체제는 이를 통해 CPU를 효율적으로 사용하여 시스템 전반적인 성능을 향상시킨다.

스케줄링은 운영체제의 특징과 시스템 요구사항에 따라 다양한 알고리즘 방식으로 동작하는데, 이 부분은 추후 자세히 다루기로 하자.

대표적으로 FCFS, SJF, Priority, RR 등이 존재한다.

## 프로세스 상태와 상태 전이

PCB에서 일반적으로 저장하고 있는 정보 중 하나는 프로세스 상태이다.
PCB는 운영 체제의 핵심 개념 중 하나라고도 말할 만큼 중요한 정보들이 저장되어 있는 곳인데 여기에서 상태는 무엇을 의미하는 것일까?

<img width="1135" height="353" alt="image" src="https://github.com/user-attachments/assets/df004f37-7a91-4164-99c9-f1bb5e1b47b4" />

메인 메모리 속에서는 이렇게 상태가 변화한다. (활성 상태)

### 프로세스 상태

프로세스 상태는 프로세스가 실행되는 동안 변경되는 고유 상태를 의미한다.
프로세스가 생성되어서 실행하고, 종료하기까지 프로세스는 여러 상태를 가지게 되고, 이 상태 변화에 따라 프로세스가 동작한다.

<img width="1034" height="495" alt="image" src="https://github.com/user-attachments/assets/89fdb071-e513-4cd2-87fd-625379f8ca68" />

- 보류 상태
    
    프로세스를 수행하다가 메모리에서 잠시 제거했다가 시간이 지난 후 다시 메모리에 넣고 수행을 이어나가는 것이 더욱 좋은 경우가 존재할 수 있다.
    
    이를 위해 프로세스를 메모리에서 디스크로 쫓아내 여유 공간을 마련하는 작업을 스와핑이라고 한다.
    중기 스케줄러(Meidium-Term Scheduler)가 이를 수행하는데, 이 스와핑에 의해 나타나는 상태가 보류 상태(SUSPENDED/STOPPED)이다.
    
    위의 활성화 상태(생성/준비/실행/대기/종료 상태)와의 차이점은 외부에서 다시 시작(적재)을 해 주어야만 활성화가 될 수 있다는 점이다.
    
    - SUSPENDED READY: 준비 상태였으나, 스와핑에 의해 디스크로 쫓겨난 상태(swap-out)
        - 프로세스가 메인 메모리로 다시 적재(swap-in)된다면 다시 READY 상태가 된다.
    - SUSPENDED WAIT / SUSPENDED BLOCKED: 대기 상태에서 메모리 공간을 잃은 상태
        - 입출력이나, 기다리던 이벤트의 종료 시 보류 준비 상태로 바뀌게 된다.

### 프로세스 상태 전이

프로세스 상태 전이란, 프로세스가 실행되는 동안 상태가 OS에 의해 변경되는 것을 말한다.

운영체제는 프로세스 스케줄링 전략을 통해 프로세스의 상태를 변경하여 관리하고 제어한다.

# 참고자료

https://growth-coder.tistory.com/139

https://yoongrammer.tistory.com/52

https://velog.io/@cchloe2311/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B5%AC%EC%A1%B0

https://product.kyobobook.co.kr/detail/S000061584886

https://j-su2.tistory.com/63

https://ground90.tistory.com/100

https://rebro.kr/172

https://m42-orion.tistory.com/129

https://jutudy.tistory.com/20
