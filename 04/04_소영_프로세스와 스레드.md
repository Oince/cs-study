# 프로세스와 스레드

## 프로세스와 컴파일 과정

**프로그램**은 **디스크에 저장된 실행 가능한 코드 그 자체**입니다.

아직 실행되지 않아 실제 작업을 수행하지는 않지만, 작업을 수행하기 위해 꼭 필요한 설계도 같은 역할입니다.

**프로세스**는 **메모리에 올라가 컴퓨터에서 실행되고 있는 프로그램의 인스턴스**입니다.

CPU 스케줄링의 대상이 되는 작업(task)와 거의 같은 의미입니다.

프로그램이 설계도라면, 프로세스는 설계도를 기반으로 지어진 집이라고 볼 수 있습니다.

<img width="481" height="161" alt="image" src="https://github.com/user-attachments/assets/aa06d49f-80a1-45f1-8d2b-e195dbad80d6" />

즉, 프로세스는 프로그램이 메모리에 올라가 인스턴스화된 것을 말합니다.

예를 들어, 구글 크롬 프로그램(chrome.exe)를 클릭하여 실행시키면 크롬 프로세스가 됩니다.

<img width="971" height="251" alt="image" src="https://github.com/user-attachments/assets/5eb7c3e9-8cbd-492f-967e-a21ead3bd20a" />

### 1\. 전처리

컴퓨터가 이해할 때 필요 없는 소스 코드의 주석을 제거하고, 헤더 파일을 병합하는 등 소스 코드를 전처리합니다.

### 2\. 컴파일러

**전처리된 코드를 어셈블리어로 변환**합니다.

코드를 C, C++ 등 사람이 쓰기 편한 언어는 CPU가 바로 이해할 수 없습니다.

0과 1의 기계어를 사람이 읽을 수 있는 로우 레벨 수준으로 표현한 것이 어셈블리어입니다.

### 3\. 어셈블러

**어셈블리어를 기계어로 변환**합니다.

각 명령어를 CPU가 이해할 수 있는 0과 1로 변환합니다.

결과물로 **오브젝트 파일**(목적 파일)이 나오는데 리눅스에서는 .o 파일에 해당합니다.

### 4\. 링커

**여러 목적 파일들과 프로그램 내에 있는 라이브러리 함수들을 결합하여 하나의 파일로 연결**하는 것을 **링킹**이라고 합니다.

결과적으로 .exe나 out 등의 확장자를 가진 **실행 파일**이 만들어집니다.

라이브러리를 링크하는 방법은 정적 링크와 동적 링크로 나눠집니다.

-   정적 링크
    -   프로그램 빌드 시 라이브러리가 제공하는 모든 코드를 실행 파일에 넣는 방식
    -   외부 의존도가 낮지만 코드 중복 등 메모리 효율성이 저하됨
-   동적 링크
    -   프로그램 실행 시 필요한 라이브러리를 실행 중에 메모리에 연결하는 방식
    -   실행 파일 안에 라이브러리 코드가 포함되지 않고, 실행 시점에 외부 라이브러리를 불러오는 것 
    -   메모리 효율성은 높지만, 외부 의존도가 높아지는 단점이 있음

---

## 프로세스의 상태

<img width="841" height="461" alt="image" src="https://github.com/user-attachments/assets/674bc1a2-7f65-4796-bf30-e366baed87c4" />

### 1\. 생성 상태(New/Create)

**프로세스가 생성되었지만 아직 메모리에 로드되지 않은 상태**입니다.

\`fork()\` 또는 \`exec()\` 함수를 통해 프로세스를 생성할 수 있는데

이때 PCB가 할당되며 PID(프로세스 ID), 메모리 주소 등 기본 정보가 기록됩니다.

-   \`fork()\`
    -   부모 프로세스를 복제하여 자식 프로세스를 생성
    -   부모 프로세스와 거의 동일한 메모리, 코드, 데이터를 가지는 별개의 새로운 프로세스
    -   → 새로운 PID
-   \`exec()\`
    -   현재 프로세스를 다른 프로그램으로 덮어씌우기
    -   프로세스 자체는 그대로 두고 코드와 데이터 영역을 새롭게 바꿈
    -   → PID는 그대로 유지

### 2\. 대기 상태(Ready)

생성된 프로세스는 **메모리에 올라가** **CPU 자원을 할당 받기를 기다립니다.**

CPU 스케줄러로부터 CPU 소유권이 넘어오기만을 **대기하고 있는 실행 준비 완료 상태**입니다.

### 3\. 대기 중단 상태(Ready Suspended)

**대기 상태로 메모리에 올라간 상태였지만 메모리 부족으로 디스크 등으로 밀려날 수 있습니다.**

이 경우 대기 상태와 CPU를 기다리는 것은 동일하지만 **CPU 할당 전 메모리로 복귀가 먼저 필요한 대기 중단 상태**가 됩니다.

비유하자면,

-   **대기 상태**: “대기 의자에 앉아 바로 호출될 수 있는 사람”
-   **대기 중단 상태**: “휴게실로 잠시 이동한 사람, 다시 불러야 의자에 앉힐 수 있음”

### 4\. 중단 상태(Blocked/Waiting)

**특정 이벤트가 발생하여 프로세스가 이벤트가 완료될 때까지 CPU 사용을 잠시 멈춘 상태**입니다.

이 상태 동안은 CPU를 사용하지 않아 **다른 프로세스에게 CPU를 양보**합니다.

주로 I/O 디바이스에 의한 인터럽트가 발생했을 때 CPU가 필요 없으므로 중단 상태에 돌입하고,

이벤트가 완료되면 다시 대기(Ready) 상태도 돌아가 CPU 할당을 기다립니다.

### 5\. 일시 중단 상태(Blocked Suspended)

**중단 상태에서 대기 상태로 돌아가려 했지만 메모리 부족으로 밀려난 상태**입니다.

대기 중단과 비슷해보이네요.

### 6\. 실행 상태(Running)

**대기 상태에서 CPU 소유권과 메모리를 할당 받으면 실행 상태**가 되어

실제 명령어를 수행합니다.

### 7\. 종료 상태(Terminated)

프로세스가 작업을 끝내고

**메모리와 CPU 소유권을 모두 놓고 가는 상태**입니다.

OS는 PCB 등 자원을 회수해갑니다.

---

## 프로세스의 메모리 구조

<img width="301" height="461" alt="image" src="https://github.com/user-attachments/assets/e4a7dc42-5e81-4fe8-ab32-6014ce2dd93f" />

### 스택과 힙

-   동적 할당 영역: 런타임 단계에서 메모리를 할당 받음
-   스택: 지역 변수, 매개변수 등이 저장되는 영역
    -   실행되는 함수에 의해 늘어나거나 줄어드는 영역으로, 함수가 호출될 때마다 호출될 때의 환경 등 특정 정보가 스택에 계속해서 저장됨
    -   재귀 함수가 호출될 때 새로운 스택 프레임이 매번 사용 → 함수 내의 변수들이 다른 함수의 변수들에 영향을 끼치지 않음
-   힙: 동적으로 할당되는 변수들이 저장되는 영역
    -   \`malloc()\`, \`free()\` 함수를 통해 관리할 수 있음
    -   동적으로 관리되는 자료 구조를 관리 ex) vector

### 데이터 영역과 코드 영역

-   정적 할당 영역: 컴파일 단계에서 메모리를 할당 받음
-   BSS Segment
    -   전역 변수 또는 static/const로 선언되어 있고 **0으로 초기화되어 있거나 또는 아예 초기화가 되지 않은 변수**들이 저장되는 영역
-   Data Segment
    -   전역 변수 또는 static/const로 선언되어 있고 **0이 아닌 값으로 초기화된 변수**들이 저장되는 영역
-   Code/Text Segment
    -   프로그램의 코드

---

## PCB(Process Control Block)

PCB란, 운영체제에서 **프로세스에 대한 메타데이터를 저장한 데이터 블록**을 말합니다.

운영체제가 프로세스를 관리하고 추적하기 위한 프로세스의 신분증 같은 존재입니다.

이런 정보가 저장됩니다.

-   프로세스 ID(PID)
-   프로세스 스케줄링 상태(대기, 일시중단 등)
-   프로세스 권한: 컴퓨터 자원 또는 I/O 디바이스에 대한 권한 정보
-   프로그램 카운터: 프로세스에서 실행해야 할 다음 명령어의 주소에 대한 포인터
-   CPU 레지스터, CPU 스케줄링 정보 등등

프로세스가 생성되면 운영체제가 PCB를 생성하며,

프로세스의 중요한 정보를 포함하고 있기 때문에 일반 사용자가 접근하지 못하도록

커널 스택의 가장 앞부분에서 관리됩니다.

### 컨텍스트 스위칭 (Context Switching)

컨텍스트 스위칭은 PCB를 기반으로 프로세스의 상태를 저장하고 로드하는 과정입니다.

한 시점에 한 개의 프로세스를 실행하는 싱글 코어 CPU 환경을 기준으로 알아봅시다.

CPU 하나로 여러 프로세스를 동시에 수행하려면 프로세스 실행 순서를 전환해야 합니다.

하나의 프로세스가 끝나기 전에 다른 프로세스로 잠깐 전환되어 작업을 하고, 다시 원래 프로세스로 돌아오기도 합니다.

이때 컨텍스트 스위칭을 통해 각 프로세스는 자신이 어디부터 이어서 실행하면 되는지를 기억할 수 있습니다.

<img width="851" height="763" alt="image" src="https://github.com/user-attachments/assets/eb18cc7c-682d-4834-a518-1b472693d6fa" />

어떤 프로세스 A를 실행하다가 다른 프로세스 B로 전환하려면

프로세스 A의 PCB를 저장하고, 프로세스 B의 PCB를 로드합니다.

작업이 끝나면 다시 프로세스 B에서 A로 전환하기 위해

프로세스 B의 PCB를 저장하고, 프로세스 A의 PCB를 로드합니다.

컨텍스트 스위칭으로 인해 유휴 시간과 캐시 미스라는 비용이 발생합니다.

잠시 CPU가 작업을 멈추고 PCB를 저장하고, 로드하는 시간을 유휴 시간이라고 합니다.

유휴 시간 외에도 컨텍스트 스위칭으로 현재 활성화된 프로세스가 바뀌면 메모리 주소도 바뀌므로 캐시를 클리어해 캐시미스가 발생합니다.

일반적으로는 멀티 코어 환경을 사용해 한 시점에 한 개의 프로세스만 실행되지는 않지만

하나의 CPU 코어 기준으로는 이렇게 전환이 일어난다 정도로 이해하면 되겠습니다.

---

## 요약

-   프로세스: 메모리에 올라가 컴퓨터에서 실행되고 있는 프로그램
-   컴파일 과정: 전처리 → 컴파일 → 어셈블러 → 링커
    -   전처리: 주석 제거, 헤더 병합 등
    -   컴파일: 코드를 어셈블리어로 변환
    -   어셈블러: 어셈블리어를 목적 파일(기계어)로 변환
    -   링커: 목적 파일과 라이브러리를 연결해 실행 파일 생성
-   프로세스 상태
    -   생성, 대기, 대기 중단
    -   중단, 일시 중단
    -   실행, 종료
-   프로세스의 메모리 구조
    -   스택: 동적 할당, 지역 변수 등 저장
    -   힙: 동적 할당, 동적으로 할당되는 변수들 저장
    -   데이터 영역: 정적 할당
        -   BSS: 0으로 초기화 또는 초기화되지 않은 변수들
        -   Data: 0이 아닌 값으로 초기화된 변수들
    -   코드: 정적 할당, 프로그램의 코드 저장
-   PCB
    -   프로세스 ID, 상태, 권한 등 메타데이터 저장
    -   컨텍스트 스위칭에 이용
-   컨텍스트 스위칭
    -   프로세스 전환 시 PCB를 기반으로 문맥을 저장하고 복원함

---

참고자료

[프로세스의 컴파일](https://june-17.tistory.com/343)

[\[CS전공지식면접\] PCB와 컨텍스트 스위칭](https://blog.naver.com/jhc9639/222714242851)


## 멀티 프로세싱

멀티 프로세싱은 말 그대로 여러 개의 프로세스를 통해 동시에 두 가지 이상의 일을 수행할 수 있는 것을 말합니다.

-   하나 이상의 일을 병렬로 처리할 수 있고
-   한 프로세스에 문제가 생겨도 다른 프로세스를 이용하면 되니 안정적입니다.

##  IPC (Inter Process Communication)

일반적으로는 각 프로세스는 독립된 메모리 공간을 가지고 있으므로, 변수 공유가 불가능합니다.

따라서 멀티 프로세싱 환경에서 프로세스 간 데이터를 주고 받기 위한 별도의 통신 수단이 필요하고, 그것이 IPC입니다.

### 공유 메모리 (Shared Memory

여러 프로세스에 동일한 메모리 블록에 대한 접근 권한이 부여되어  
프로세스가 서로 통신할 수 있도록 공유 메모리를 생성해서 통신하는 방법입니다.

기본적으로는 각 프로세스의 메모리를 다른 프로세스가 접근할 수 없지만

공유 메모리를 통해 **여러 프로세스가 하나의 메모리를 공유**할 수 있습니다.

-   메모리 자체를 공유하기 때문에 불필요한 데이터 복사가 없어 가장 빠른 방법
-   여러 프로세스 간 같은 데이터를 볼 수 있도록 동기화가 필요

### 파일 (File)

디스크에 저장된 공용 파일을 쓰거나 읽어 통신하는 방법입니다.

디스크 접근이 필요하므로 속도가 느리고, 동기화에 신경서야 합니다.

### 소켓 (Socket)

클라이언트가 데이터를 요청하고, 서버는 클라이언트 요청에 응답하는 것도 IPC의 예입니다.

소켓은 클라이언트와 서버가 특정 포트를 통해 양방향 통신을 하는 방식으로 네트워크 인터페이스를 통해 데이터를 전송합니다.

TCP와 UDP가 있습니다.

### 파이프 (Pipe)

프로세스 간 통신을 위해 추가의 메모리 공간을 할당하여 데이터를 주고 받는데

이 공간을 파이프라고 합니다.

<img width="512" height="101" alt="image" src="https://github.com/user-attachments/assets/cfa554e4-e8af-4536-aba2-5f16284179c6" />

### 익명 파이프 (Unnamed Pipe / Anonmous Pipe)

-   프로세스 간 임시 데이터 통로 = 일시적으로 사용하는 이름 없는 통로
-   FIFO 방식 통신
-   단방향 통신만 지원
    -   한쪽 프로세스는 쓰기만, 다른 쪽은 읽기만 가능
    -   양방향이 필요하면 파이프 두 개를 만들어야 함
-   부모-자식 프로세스 간 통신에 자주 사용
    -   완전히 무관한 프로세스끼리는 사용 불가
-   임시 통로
    -   프로세스가 종료되면 파이프도 함께 사라짐

<img width="511" height="101" alt="image" src="https://github.com/user-attachments/assets/8928ff1c-71ba-44d9-ab8e-83fded047fbd" />

### 명명된 파이프 (Named Pipe)

-   이름을 가진 파이프로, 프로세스들이 이 이름을 통해 파이프에 접근
    -   서로 무관한 프로세스도 파이프 이름만 알고 있으면 통신 가능
-   단방향 또는 양방향 지원
-   클라이언트/서버 통신을 위한 별도의 파이프를 제공
    -   하나의 프로세스가 서버 역할로 파이프를 열어두고,
    -   여러 클라이언트 프로세스가 연결해서 읽기/쓰기를 수행하면 됨
-   여러 파이프 동시에 사용 가능
    -   서로 다른 파이프를 만들어 병렬로 독립적인 통신 채널 확보 가능
-   한 컴퓨터의 프로세스끼리 사용 가능하지만, 다른 네트워크 상의 컴퓨터와도 통신 가능
-   파일 시스템에서 삭제하기 전까지 영속적으로 존재

<img width="673" height="720" alt="image" src="https://github.com/user-attachments/assets/ca0ad51f-13de-4e65-a9a1-9e95f213a793" />

### 메시지 큐 (Message Queue)

메시지를 큐(queue) 데이터 구조 형태로 관리하는 방법입니다.

-   커널에서 전역적으로 관리
    -   공유 메모리보다 속도는 느리지만 안정
-   큐 = FIFO 방식
    -   발신자 프로세스가 메시지를 큐에 넣고, 수신자 프로세스가 꺼내 사용하는 방식
-   비동기 통신 지원
    -   보낸 프로세스가 즉시 응답을 받을 필요없이 메시지만 넣고 끝
-   메지지를 큐에 쌓으면 송신자와 수신자가 반드시 동시 실행될 필요 없어서 독립적
-   사용 방법이 직관적이고 간단

## 스레드와 멀티스레딩

### 스레드

스레드는 **프로세스 안에서 독립적으로 실행되는 흐름의 단위**로,

하나의 프로세스는 여러 스레드를 가질 수 있습니다.

<img width="1280" height="720" alt="image" src="https://github.com/user-attachments/assets/f3702e5d-cd2d-4cfb-bb46-6858a64533f4" />

스레드는 코드(text), 데이터, 힙 영역은 프로세스의 것을 공유하고,

스택 영역은 스레드마다 새롭게 할당받아 별도의 스택을 가집니다.

### 멀티스레딩

멀티스레딩은 프로세스 내 작업을 여러 개의 스레드, 멀티스레드로 처리하는 기법입니다.

스레드끼리는 자원을 서로 공유하기 때문에 멀티프로세스보다 컨텍스트 스위칭이 가벼워 성능에 유리합니다.

또한 한 스레드가 중단(blocked)되어도 다른 스레드는 실행(running) 상태일 수 있기 때문에 중단되지 않은 빠른 처리가 가능합니다.

그러나 한 스레드에 문제가 생기면 다른 스레드에 영향을 끼쳐 결과적으로 프로세스에 영향을 줄 수 있는 위험이 있습니다.

책에서는 이러한 예를 들고 있습니다.

---

## 공유 자원과 임계 영역

### 공유 자원 (Shared Resource)

공유 자원은 **시스템 안에서 각 프로세스, 스레드가 함께 접근할 수 있는 자원**으로,

모니터, 프린터, 메모리, 파일, 데이터 등이 될 수 있습니다.

이러한 **공유 자원에 두 개 이상의 프로세스(혹은 스레드)가 동시에 읽거나 쓰는 상황**을 **경쟁 상태(race condition)**이라고 합니다.

여러 프로세스(혹은 스레드)가 동시에 접근을 시도할 대 접근의 타이밍이나 순서 등이 결괏값에 영향을 줄 수 있습니다.

책에서는 이런 예시를 들고 있습니다.

코인 100개가 있고, 프로세스 A와 B에서 코인을 100개씩 증가시키려고 합니다.

<img width="1083" height="564" alt="image" src="https://github.com/user-attachments/assets/564545bd-e361-4289-b6ab-9fb87c9e0dee" />

프로세스 A와 B가 동시에 코인 개수 변수에 접근하여

타이밍이 꼬여 정상 결과값 300 대신 200이 출력됩니다.

### 임계 영역 (Critical Section)

임계 영역은 둘 이상의 프로세스(혹은 스레드)가 공유 자원에 접근할 때

순서 등의 이유로 수행 결과가 달라지는 코드 영역을 말합니다.

즉, **둘 이상의 프로세스(혹은 스레드)가 임계 영역에 동시에 진입하면 안 되는 영역**입니다.

```
public class CoinRaceCondition {

    private static int coin = 100; // 공유 자원

    public static void addCoin(int amount) {
   		// 임계 영역----------------------------------
    	int temp = coin;        // 현재 값 읽기
    	temp = temp + amount;   // 계산
    	coin = temp;            // 새로운 값 저장
        // -------------------------------------------
	}
}
```

---

### 경쟁상태 해결

둘 이상의 프로세스(스레드)가 동시에 실행되더라도 타이밍이나 실행 순서에 상관 없이 항상 같은 결과를 내려면

동기화 과정이 필요합니다.

둘 이상의 프로세스(스레드)가 임계 영역에 동시에 진입하는 것을 막아 동기화하는 방법은

**잠금(lock)**을 거는 것입니다.

잠금을 거는 방법으로 뮤텍스, 세마포어, 모니터가 있으며

이들은 모두 상호 배제, 한정 대기, 융통성 조건을 만족합니다.

-   **상호 배제(mutual exclusion)**: 한 프로세스가 임계 영역에 들어갔을 때 다른 프로세스는 들어갈 수 없다.
-   **한정 대기(bounded waiting)**: 특정 프로세스가 영원히 임계 영역에 들어가지 못하면 안 된다. 대기 후에 언젠가는 들어갈 수 있어야 한다.
    -   만약 한 프로세스가 계속 락을 잡고 있으면 다른 스레드는 영원히 임계 영역에 못 들어가는 기아(starvation) 상태에 빠질 수 있으므로, 이를 막기 위해 대기 횟수나 시간에 상한이 있어야 한다.
-   **융통성(progress)**: 만약 어떠한 프로세스도 임계 영역을 사용하지 않는다면, 임계 영역 외부의 어떠한 프로세스든지 자유롭게 들어갈 수 있으며 이때 프로세스끼리 서로 방해하지 않는다.

#### 뮤텍스(Mutex)

뮤텍스는 프로세스나 스레드가 공유 자원을 \`lock()\`을 통해 잠금 설정하고

사용한 후에는 unlock()을 통해 잠금 해제하는 객체입니다.

잠금이 설정되면 다른 프로세스나 스레드는 잠긴 코드 영역에 접근할 수 없습니다.

뮤텍스는 잠금 또는 잠금 해제라는 상태만을 가지며, 한 번에 하나의 스레드만 임계 영역에 접근하도록 보장합니다.

<img width="603" height="544" alt="image" src="https://github.com/user-attachments/assets/5deedc90-981c-436f-b73f-6b46b9b41a9f" />

#### 세마포어(Semaphore)

뮤텍스가 lock을 기반으로 제어한다면 세마포어는 신호를 기반으로 제어합니다.

현재 **공유 자원에 접근할 수 있는 프로세스(스레드)의 수**를 나타내는 값을 **세마포어 값**이라는 변수로 관리하여 그 수를 만족하는 경우에만 임계 영역에 접근할 수 있도록 합니다.

세마포어는 간단한 정수 값과 두 가지 함수 P 연산과 V 연산으로 공유 자원에 대한 접근을 처리합니다.

-   프로세스나 스레드가 공유 자원에 접근하고 싶다면 임계 영역에 들어가기 전 → P 연산(\`wait()\`) 수행
-   프로세스나 스레드가 임계 영역 사용을 마치면 다음 대기 중인 프로세스(스레드)가 진입할 수 있도록  → V 연산(\`signal()\`) 수행

세마포어에는 두 가지 유형이 있습니다.

-   바이너리 세마포어: 현재 임계 영역에 접근할 수 있는 프로세스(스레드) 개수가 0 또는 1만 되는 세마포어
    -   세마포어 값이 0이며 임계 영역에 접근할 수 없고(잠금), 1이면 접근할 수 있다(잠금 해제)
-   카운팅 세마포어
    -   0과 1뿐만 아니라 더 큰 값을 세마포어 값으로 하여 미리 지정한 최대 N개의 프로세스(스레드)가 임계 영역에 접근할 수 있다

#### 모니터(Monitor)

둘 이상의 스레드나 프로세스가 공유 자원에 안전하게 접근할 수 있도록

공유 자원을 캡슐화로 숨겨 외부에서 직접 건드리지 못하게 하고, 해당 접근에 대해 모니터라는 인터페이스만 제공하는 방법입니다.

-   공유 자원은 외부에서 직접 접근할 수 없고, **모니터가 제공하는 메서드**를 통해서만 접근할 수 있습니다.
-   모니터 안의 메서드는 자동으로 상호 배제(Mutual Exclusion)를 보장하므로 개발자가 직접 락을 관리할 필요가 없습니다.

---

참고자료

[\[Thread\] 뮤텍스, 세마포어, 모니터의 스레드 동기화와 구현 예제](https://jbground.tistory.com/73)

## 교착 상태 (Deadlock)

**: 두 개 이상의 프로세스들이 서로가 가진 자원을 기다리며 중단된 상태**

프로세스 A가 프로세스 B가 사용하고 있는 어떤 자원을 요청할 때

프로세스 B도 프로세스 A가 점유하고 있는 자원을 요청하는 경우 발생합니다.

두 프로세스 모두 상대방의 작업이 끝나기만을 기다리고 있기 때문에 결과적으로 아무것도 완료되지 못하는 상태입니다.

예를 들어 하나의 사다리가 있고, 두 명의 사람이 각각 사다리의 위쪽과 아래쪽에 있다고 해봅시다.

아래에 있는 사람은 위로 올라가려고 하고, 위에 있는 사람은 아래로 내려오려고 한다면

두 사람은 서로 상대방이 아예 사다리에서 비켜주지 않는다면 기다리기만 하고, 결과적으로는 아무도 사다리를 내려오거나 올라가지 못하게 됩니다.

---

### 교착 상태의 원인

교착 상태는 4가지 조건을 모두 만족했을 때 발생합니다.

-   **상호 배제(Mutual Exclusion)**
    -   **"자원은 한 번에 하나의 프로세스만 사용할 수 있다."**
    -   한 프로세스가 자원을 독점하고 있으며 다른 프로세스들은 접근이 불가능한 상태입니다.
-   **점유 대기(Hold and Wait)**
    -   **"최소 한 개의 자원을 보유한 상태에서 다른 자원을 기다린다."**
    -   특정 프로세스가 점유한 자원을 다른 프로세스가 요청하는 상태입니다. 사다리 예시에서 자원은 사다리의 윗쪽과 아랫쪽이 됩니다.
-   **비선점(Non-preemption)**
    -   **"이미 할당된 자원은 강제로 빼앗을 수 없다."**
    -   다른 프로세스의 자원을 강제로 빼앗지 못하고 획득하기 위해서는 계속 대기해야 합니다. 비선점 모드에서는 내가 얻고자 하는 자원을 이용하는 다른 프로세스의 작업이 끝나야지만 자원을 이용할 수 있습니다.
-   **환형 대기/원형 대기(Circular Wait)**
    -   **"프로세스들이 서로의 자원을 기다리며 원형 상태로 대기한다."**
    -   프로세스 A는 프로세스 B의 자원을 요구하고, 프로세스 B는 프로세스 A의 자원을 요구하는 끝없는 순환입니다.

<img width="936" height="582" alt="image" src="https://github.com/user-attachments/assets/735d230f-1a03-4b48-baf6-e57b08f0ddbd" />

---

### 교착 상태의 해결 방법

교착 상태를 해결하는 방법으로는

아예 문제가 발생하지 않도록 하는 **예방**과 교착 상태가 일어날 것 같으면 자원 할당을 멈추는 **회피**,

또한 자원을 마음껏 할당하다가 교착 상태가 **탐지**되면 교착 상태에서 **회복**하는 방법이 있습니다.

#### 예방(Prevention)

자원을 할당할 때 애초에 교착 상태가 일어나지 않도록 설계합니다.

교착 상태의 4가지 원인을 미리 제거하는 겁니다.

-   상호 배제 제거: 여러 프로세스가 공유 자원에 동시에 접근하도록 허용. 현실적으로 불가능.
-   점유 대기: 프로세스 실행 전에 모든 자원을 미리 할당. 한 프로세스에 필요한 자원들을 모두 몰아주어 한 프로세스만 작업.
-   비선점 제거: 자원을 점유하고 있다가 다른 프로세스가 자원을 요구하면 반납
-   원형 대기 제거: 모든 자원에 번호를 할당하고, 이 순서에 따라 자원을 할당하여 원형 대기 예방

#### 회피(Avoidance)

실행 도중에 교착 상태가 발생할 가능성을 검사해

교착 상태 가능성이 없을 때만 조심스럽게 자원을 할당하는 방법입니다.

회피를 표현한 알고리즘으로 은행원 알고리즘이 있습니다.

-   **은행원 알고리즘(Banker's Algorithm)**
    -   은행원은 대출을 해줄 때 마구잡이로 하지 않는다.  
        은행이 고객에게 돈을 줘도 파산하지 않을지, 대출을 받은 고객이 돈을 갚을 수 있을지 등  
        "지금 이 고객에게 돈을 빌려줘도 괜찮을까?" 안전한지 시뮬레이션을 해보고 돈을 내어 준다.
    -   즉, 은행원 알고리즘은 **자원을 요청받았을 때, 데드락을 일으키지 않는 안전한 상태인지 시뮬레이션해보고**  
        **괜찮을 때 자원을 배분해주는 알고리즘**이다.

#### 탐지(Detection)와 회복(Recovery)

예방과 회피는 교착 상태를 사전에 막기 위한 노력이라면,

탐지와 회복은 교착 상태가 발생한 후 조취를 취하는 방법입니다.

**탐지는 주기적으로 자원 할당 상태를 확인하여 교착 상태가 있는지 검사하는 것**입니다.

RAG라는 자원 할당 그래프를 그렸을 때 원형 대기 사이클이 생기는지 보는 것입니다.

회복은 크게 두 가지 방법으로 나누어집니다.

-   **선점을 통한 회복**
    -   교착 상태가 해결될 때까지 프로세스에서 자원을 빼앗아 함께 교착 상태에 빠진 다른 특정한 한 프로세스에게 자원을 할당한다.
-   **프로세스 강제 종료를 통한 회복**
    -   교착 상태는 매우 드물게 일어나기 때문에 이를 처리하는 비용이 더 클 수 있다. → 그냥 해결하지 말고 강제 종료해버리자!

---

참고자료

[교착 상태](https://ko.wikipedia.org/wiki/%EA%B5%90%EC%B0%A9_%EC%83%81%ED%83%9C)

[데드락(Deadlock) 의 발생조건과 이를 해결하기 위한 4가지 방안(예방, 회피, 검출, 회복)](https://haon.blog/cs/os/deadlock/)
