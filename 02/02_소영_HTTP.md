> 이 포스팅은 주홍철 저 '면접을 위한 CS 전공지식 노트' 2.5장을 토대로 작성되었습니다.

## ✅ HTTP란?

> **Hyper Text Transfer Protocol**

HTTP는 애플리케이션 계층 프로토콜로,

웹에서 **서버와 클라이언트가 서로 데이터를 주고받기 위해 사용되는 통신 규악**입니다.

쉽게 말하자면 웹 브라우저가 서버와 통신하는 규칙입니다.

이 글에서는 HTTP 1.0부터 3까지 발전 과정을 살펴봅니다.

---

## 📌 HTTP/1.0

<img width="600" height="583" alt="image" src="https://github.com/user-attachments/assets/0e91897c-d061-460b-8d37-7f960602bdf6" />


-   **기본적으로 한 연결당 하나의 요청을 처리**
-   → 서버로부터 파일을 가져올 때마다 TCP의 3-way handshake를 계속해서 해야 함
-   → **RTT가 증가**하는 문제 발생
    -   **RTT**: 패킷이 목적지에 도달하고 나서 다시 출발지로 돌아오기까지 걸리는 시간 = 패킷 왕복 시간

### HTTP/1.0에서 RTT의 증가를 해결하기 위한 방법

매번 연결할 때마다 RTT가 증가하니, 서버에 부담도 증가하고 사용자 응답 시간이 길어졌고,

이를 해결하기 위해 1. 이미지 스플리팅 2. 코드 압축 3. 이미지 Base64 인코딩을 사용했습니다.

#### 이미지 스플리팅

-   많은 이미지가 합쳐 있는 하나의 이미지를 다운로드받아 과부하 방지
-   \`background-image\`의 \`position\`을 이용하여 이미지를 표기

하나의 이미지 icons.png를 기반으로 \`background-position\`을 통해 2개의 이미지를 설정한 코드

```
#icons>li>a {
    background-image: url("icons.png");
    width: 25px;
    display: inline-block;
    height: 25px;
    repeat: no-repeat;
}
#icons>li:nth-child(1)>a {
    background-position: 2px -8px;
}
#icons>li:nth-child(2)>a {
    background-position: -29px -8px;
}
```

#### 코드 압축

-   개행 문자, 빈칸을 없애서 코드의 크기를 최소화하는 방법
-   코드가 압축되어 코드 용량이 줄어듦

#### 이미지 Base64 인코딩

-   이미지 파일을 64진법으로 이루어진 문자열로 인코딩
-   장점: 이미지에 대해 서버에 HTTP 요청을 보낼 필요가 없음
-   단점: 이미지를 Base64 문자열로 변환하면 용량이 37% 증가

---

## 📌 HTTP/1.1

-   매번 TCP 연결을 하지 않고,  
    하나의 TCP 연결에서 \`keep-alive\` 옵션으로 여러 개의 파일을 송수신
-   참고) \`keep-alive\` 옵션은 원래 있었지만 1.0부터 표준화가 되어 기본 옵션으로 설정

1.1에서는 한 번 TCP 3-way handshake가 일어나면  
그 이후에는 연결을 끊지 않고 **keep-alive** 옵션으로 재사용할 수 있습니다.

  
즉, 지정한 timeout 동안 연결을 유지하면서 여러 요청을 처리할 수 있습니다.  
또한 HTTP/1.1에서는 **파이프라이닝(pipelining)** 기능도 도입되어,  
클라이언트가 응답을 기다리지 않고 여러 요청을 연속적으로 보낼 수 있습니다.

<img width="600" height="500" alt="image" src="https://github.com/user-attachments/assets/8ac10e02-5873-4f3f-a6ba-0f72552398fa" />


다만 응답은 반드시 순서대로 도착해야 하므로,  
첫 번째 응답이 지연되면 뒤 요청들도 지연되는 HOL Blocking 문제가 발생했습니다.

### HTTP/1.1의 문제: HOL Blocking

-   HOL Blocking(Head Of Line Blocking)
-   네트워크에서 같은 큐에 있는 패킷이 그 첫 번째 패킷에 의해 지연될 때 발생하는 성능 저하 현상

<img width="600" height="209" alt="image" src="https://github.com/user-attachments/assets/326d81d6-e54f-4164-974f-30372f3eee8f" />


첫 번째 파일인 \`image.jpg\`를 받는데 오래 걸리면 그 뒤에 있는 것들이 그만큼 대기하게 되여

전체적으로 다운로드가 지연되는 현상입니다.

즉, 우선순위로 들어온 요청의 응답 시간이 길어지며 후 순위에 있는 요청의 응답 시간도 길어진다는 단점입니다.

### HTTP/1.1의 문제: 무거운 헤더 구조

-   헤더에 쿠키 등 많은 메타데이터가 들어 있고, 압축이 되지 않아 무거움

---

## 📌 HTTP/2

-   SPDY 프로토콜에서 파생
-   HTTP/1.x보다 지연 시간 단축 → 응답 시간 단축
-   멀티플레싱, 헤더 압축, 서버 푸시, 요청의 우선순위 처리 지원

> SPDY 프로토콜?  
> 스피티 프로토콜이라 읽으며, 웹 콘텐츠를 전송할 목적으로 구글에서 개발한 비표준 네트워크 프로토콜  
> 출처: [https://ko.wikipedia.org/wiki/SPDY](https://ko.wikipedia.org/wiki/SPDY)

### 특징 1. 멀티플렉싱

-   여러 개의 스트림을 사용하여 송수신하는 것
    -   스트림(stream): 시간이 지남에 따라 사용할 수 있게 되는 일련의 데이터 요소를 가리키는 데이터 흐름
-   여러 개의 스트림을 사용하므로, 특정 스트림의 패킷이 손실되어도 해당 스트림에만 영향을 끼치고,  
    나머지 스트림은 멀쩡하게 동작 가능
-   → 단일 연결을 사용하여 병렬로 여러 요청을 처리할 수 있음!
-   → HTTP/1.1의 HOL Blocking 문제 해결

### 특징 2. 헤더 압축

-   HTTP/1.x에서 무거운 헤더를 사용하던 것을 개선
-   허프만 코딩 압축 알고리즘을 사용하는 HPACK 압축 형식을 가짐
    -   허프만 코딩: 빈도가 높은 정보는 적은 비트 수를 사용해 표현, 빈도가 낮은 정보는 비트 수를 많이 사용하여 표현하여 전체 테이터의 표현에 필요한 비트를 줄이는 원리

### 특징 3. 서버 푸시

-   HTTP/1.1에서는 클라이언트가 서버에 요청을 해야 파일을 다운로드할 수 있음
-   HTTP/2에서는 클라이언트 요청 없이 서버가 바로 리소스를 푸시할 수 있음

<img width="600" height="357" alt="image" src="https://github.com/user-attachments/assets/7bdb2ab0-072c-4559-91d2-92a678502b5a" />


html에는 일반적으로 css나 js 파일이 포함되는데

HTTP/1.1까지는 css나 js 파일을 다운로드하기 위해 여러 번 요청을 보내야 했습니다.

HTTP/2부터는 클라이언트가 html 파일만 요청하면 그 안에 들어 잇던 css, js 파일까지

클라이언트에게 줄 수 있습니다(푸시).

### 특징 4. 요청 우선순위 처리

-   멀티플렉싱으로 여러 요청을 동시에 보낼 수 있게 되면서, 어떤 리소스를 먼저 처리할지 결정할 필요가 생김
-   클라이언트는 각 요청(스트림)에 **우선순위(priority)** 값을 지정할 수 있음
-   서버는 이 정보를 참고하여 중요한 리소스(css, js)를 먼저 전송하고, 덜 중요한 리소스(이미지, 광고)는 나중에 전송
-   → 페이지 렌더링 속도 최적화 가능

---

## 📌 HTTPS

-   애플리케이션 계층과 전송 계층 사이에 신뢰 계층인 SSL/TLS 계층을 넣은, 신뢰할 수 있는 HTTP 요청
-   → 통신을 암호화할 수 있음
-   HTTP/2는 HTTPS 위에서 동작

### 특징 1. SSL/TLS

-   전송 계층에서 보안을 제공하는 프로토콜
-   클라이언트와 서버가 통신할 때 SSL/TLS를 통해 제 3자가 메시지를 도청하거나 변조하지 못하도록 함
-   보안 세션을 기반으로 데이터를 암호화하여 보안 세션이 만들어질 때 인증 메커니즘, 키 교환 암호하, 해싱 알고리즘을 사용됨
    -   보안 세션: 보안이 시작되고 끝나는 동안 유지되는 세션  
        SSL/TLS은 핸드셰이크를 통해 보안 세션을 생성하고, 이를 기반으로 상태 정보 공유
-   SSL(Secure Socker Layer)에서 버전이 올라가며 TLS(Transport Layer Security Protocol)로 명칭 변경

<img width="600" height="606" alt="image" src="https://github.com/user-attachments/assets/b6f32ff7-3a68-4044-9817-1c5bf881f3c4" />


클라이언트와 서버가 키를 공유하고,

이를 기반으로 인증, 인증 확인 등의 작업이 일어나는 단 한 번의 1-RTT가 생긴 후 데이터를 송수신하고 있습니다.

클라이언트는 서버에게 어떤 암호화 알고리즘을 원하는지에 대해 보내는데

이를 사이퍼 슈트(cyper suites)라고 합니다.

제공할 수 있는 암호화 알고리즘이면 서버에서 클라이언트로 인증서를 보내는 인증 매커니즘이 시작되고, 이후 해싱 알고리즘 등으로 암호화된 데이터 송수신이 시작됩니다.

#### \+ 사이퍼 슈트

: 프로토콜, AEAD 사이퍼 모드, 해싱 알고리즘이 나열된 규약

-   \`TLS\_AES\_128\_GCM\_SHA256\`
-   \`TLS\_AES\_256\_GCM\_SHA384\`
-   \`TLS\_CHACHA20\_POLY1305\_SHA256\`
-   \`TLS\_AES\_128\_CCM\_SHA256\`
-   \`TLS\_AES\_128\_CCM\_8\_SHA256\`

#### 인증 매커니즘

-   CA(Certificated Authorities)에서 발급한 인증서를 기반으로 인증이 이루어짐
-   CA에서 발급한 인증서는 안전한 연결을 시작하는 데 있어 필요한 공개 키를 클라이언트에게 제공  
    → 사용자가 접속한 서버가 신뢰할 수 있는 서버임을 보장

#### 암호화 알고리즘: 디피-헬만 키 교환 암호화 알고리즘

-   키 교환 알고리즘으로 대수곡선 기반의 ECDHE(Elliptic Curve Diffie-Hellman Ephermeral) OR 모듈식 기반의 DHE(Diffie-Hellman Ephermeral)를 사용  
    
-   둘 다 디피-헬만(Diffie-Hellman) 방식에 기반

**디피-헬만 키 교환 암호화 알고리즘**

<img width="399" height="99" alt="image" src="https://github.com/user-attachments/assets/2891de1b-0b2c-45ac-a4fd-6963f2398456" />


위 공식에서

g와 x와 p를 안다면 y는 구하기 쉽지만

g와 y와 p만 안다면 x를 구하기는 어렵다는 원리에 기반한 알고리즘입니다.

처음에 공개 값을 공유하고 각자의 비밀 값과 혼합된 값을 공유합니다.

그 다음 각자의 비밀 값과 또 섞습니다. → 공통의 암호키가 생성됩니다.

이처럼 클라이언트와 서버 모두 개인키, 공개키를 생성된다면

악의적인 공격자는 PSK(사전 합의된 비밀 키)가 없기 때문에 아무것도 못함

<img width="600" height="828" alt="image" src="https://github.com/user-attachments/assets/be64436e-5b4a-49b9-8cca-08bd11b6003a" />


#### 해싱 알고리즘

-   데이터를 추정하기 힘든 더 작고, 섞여 있는 조각으로 만드는 알고리즘
-   SSL/TLS는 SHA-256, SHA-384 알고리즘을 자주 사용

**SHA-256 알고리즘**

-   함수의 결괏값이 256비트인 알고리즘

#### SEO에도 도움이 되는 HTTPS

-   SEO: 검색엔진 최적화
    -   검색엔진으로 웹 사이트를 검색했을 때 그 결과를 페이지 상단에 노출시켜 많은 사람들이 볼 수 있도록 하는 방법
-   구글에서 공식적으로 HTTPS를 쓰는 사이트가 SEO가 높다고 발표 → 서비스를 한다면 HTTPS로 하자..
-   많은 사람들 유입을 위한 방법으로 캐노니컬 설정, 메타 설정, 페이지 속도 개선, 사이트맵 관리 등등 있음

### HTTPS 구축 방법

1.  직접 CA에서 구매한 인증키를 기반으로 구축
2.  서버 앞단의 HTTPS를 제공하는 로드밸런서를 두기
3.  서버 앞단에 HTTPS를 제공하는 CDN을 두기

---

## 📌 HTTP/3

-   HTTP/2는 TCP에서 돌아감
-   HTTP/3은 QUIC 계층에서 돌아가며, TCP 기반이 아닌 UDP 기반
-   HTTP/2의 장점인 멀티플렉싱을 특징으로 가짐

<img width="600" height="687" alt="image" src="https://github.com/user-attachments/assets/9aaac99e-f905-4aa1-bef4-83a4fa413a96" />


#### 초기 연결 설정 시 지연 시간 감소 

-   QUIC은 TCP를 사용하지 않기 때문에 통신을 시작할 때 3-way handshake 과정 필요없음
-   첫 연결 설정에 1-RTT만 소요
    -   클라이언트가 서버에 어떤 신호를 한 번 주고, 서버도 거기에 응답하기만 하면 본 통신을 시작할 수 있음
-   QUIC은 순방향 오류 수정 메커니즘(FEC, Forword Error Correction)이 적용되어 있음
    -   전송한 패킷이 손실되었다면 수신 측에서 에러를 검출하고 수정하는 방식
    -   → 열악한 네트워크 환경에서도 패킷 손실률이 낮음

<img width="600" height="499" alt="image" src="https://github.com/user-attachments/assets/8569e758-379a-46e6-b71c-d6bf640a84f3" />


---

## 🔑 요약

HTTP란?

-   웹에서 **클라이언트-서버 간 데이터 송수신을 위한 애플리케이션 계층 프로토콜**

HTTP/1.0

-   **요청 1개마다 TCP 연결**(3-way handshake 필요) → **RTT 증가**
-   해결책: 이미지 스플리팅, 코드 압축, Base64 인코딩

HTTP/1.1

-   keep-alive로 **하나의 연결에서 여러 요청 처리**
-   응답을 기다리지 않고 연속으로 요청을 보내는 파이프라이닝 가능 → 하지만 **HOL Blocking 발생**
-   문제: 무거운 헤더(쿠키 등, 압축 X)

HTTP/2

-   **멀티플렉싱** → 병렬로 요청 전송 → HOL Blocking 해결
-   헤더가 가벼워짐(HPACK-허프만 코딩)
-   서버 푸시: 클라이언트 요청 없이 서버가 바로 리소스 푸시

HTTPS

-   HTTP + SSL/TLS → 암호화, 무결성, 인증 제공
-   주요 개념
    -   핸드셰이크: 키 교환 + 인증 + 세션 생성
    -   사이퍼 슈트: 암호화 알고리즘 조합
    -   Diffie-Hellman(ECDHE/DHE) → 안전한 키 교환
    -   해시(SHA-256/384 등)
-   SEO에도 긍정적 영향

HTTP/3

-   TCP 대신 **QUIC(UDP 기반) 사용**
-   초기 연결 1-RTT → 지연 시간 단축
-   멀티플렉싱 유지 + 순방향 오류 수정 메커니즘으로 손실 패킷 복구

## 👩‍🏫 예상 질문

| HTTP와 HTTPS 차이를 설명해주세요. | HTTP는 암호화되지 않은 애플리케이션 계층의 프로토콜이고,   HTTPS는 SSL/TLS를 통해 암호화·인증·무결성을 제공하여 안전하게 HTTP 요청을 주고받을 수 있게 합니다. |
| --- | --- |
| HTTP/2에 대해 설명해주세요. | HTTP/2는 1보다 지연 시간을 줄이고 응답 시간을 더 빠르게 하기 위해   멀티플렉싱, 헤더 압축, 서버 푸시, 요청 우선순위 처리를 지원하는 프로토콜입니다.    |
| 멀티플렉싱은 무엇인가요? | 여러 개의 스트림을 사용하여 송수신하는 것으로   하나의 스트림의 패킷이 손실되어도 다른 스트림에는 영향을 끼치지 않습니다.   이로 인해 병렬로 요청을 전송할 수 있습니다. |
| 서버 푸시는 무엇인가요? | HTTP/1.1에서는 클라이언트가 서버에 요청을 해야 파일을 다운로드받을 수 있었습니다.   HTTP/2에서는 클라이언트 요청 없이 서버가 리소스를 바로 푸시할 수 있습니다.   예를 들어, 클라이언트는 html만 요청했는데 서버가 css, js까지 푸시하여 클라이언트에게 먼저 줄 수 있습니다. |
| HTTP/1.0의 가장 큰 한계는 무엇이었나요? | HTTP/1.0은 매 요청마다 새로운 TCP 연결을 열어야 해서 지연 시간이 길고 비효율적이었습니다. |
| HOL Blocking은 무슨 문제인가요? | 하나의 연결에서 요청들이 순차적으로 처리될 때 앞선 요청이 지연되면 뒤의 요청들도 함께 지연되는 문제입니다. |
| SSL/TLS의 역할은 무엇인가요? | 전송 계층에서 보안을 제공하는 프로토콜입니다.   제3자가 메시지를 도청하거나 변조하지 못하도록 합니다. |
| HTTP/3이 TCP 대신 UDP를 사용한 이유는 무엇인가요? | HTTP/3은 QUIC 프로토콜을 기반으로 동작하는데 이 QUIC 프로토콜이 UPD를 사용합니다.   TCP가 아닌 UDP를 사용하여 3-way handshake 과정을 거칠 필요 없이 빠르게 통신을 시작할 수 있습니다. |

---

참고자료

[🌐 HTTP는 무엇일까요? - 기본 핵심 요약 총정리](https://inpa.tistory.com/entry/HTTP-%F0%9F%8C%90-%EB%B0%B1%EC%97%94%EB%93%9C-%EB%A1%9C%EB%93%9C%EB%A7%B5-HTTP%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C%EC%9A%94)
