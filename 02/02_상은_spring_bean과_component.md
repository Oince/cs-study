# 스프링 빈 (Bean) 이란?


> 스프링 컨테이너가 관리하는 자바 객체 = 빈(Bean)
> 
- 사용자는 new를 이용하여 생성하지 않고(사용자가 제어하지 않고),
스프링에 의해 관리되는 자바 객체를 사용. (제어의 역전)
- 스프링 컨테이너에 객체들을 생성하면 객체끼리 의존성을 주입하는 역할을 해 줌

⇒ 이와 같이, 스프링 컨테이너에 등록되어 스프링에 의해 관리되는 객체들을 `빈(Bean)` 이라고 함.

- 빈으로 등록된 객체는 기본적으로 `싱글톤` 스코프로 사용

# Bean 등록 방법


## #1 컴포넌트 스캔과 자동 의존관계 설정: 자동 등록

클래스 선언부 위에 @Component 어노테이션을 사용하는 것

- @Controller, @Service, @Repository는 모두 @Component를 포함하고 있음
해당 어노테이션으로 등록된 클래스들은 스프링 컨테이너에 의해 자동으로 생성되어 스프링 빈으로 등록됨.
- 기본적으로 @ComponentScan을 거치는데, 이 때 기본 스캔 위치가 해당 패키지와 하위 패키지
@SpringBootApplication을 보면, 안에 이미 컴포넌트 스캔이 포함된 것을 확인할 수 있음
    - Application 클래스 패키지를 기준으로 해당 패키지 및 하위 패키지를 스캔

## #2 자바 코드로 직접 스프링 빈 등록 (@Configuration + @Bean): 수동 등록

수동으로 스프링 빈을 등록하는 방법

자바 설정 클래스를 만들어 해당 클래스에서 스프링 빈을 등록한다.

설정 클래스를 만들고 @Configuration 어노테이션을 클래스 선언부 위에 추가

특정 타입을 리턴하는 메소드를 만들어, @Bean 어노테이션을 붙여주면 자동으로 해당 타입의 빈 객체가 생성

+) XML로 설정하는 방식도 있지만, 잘 사용하지 않음!

## 등록된 스프링 빈의 사용 방법 - 의존성 주입

1. 생성자 주입 - 가장 권장되는 방식
2. 필드 주입 - 필드에 @Autowired 어노테이션을 통해 자동으로 주입
    1. 프레임워크에 의존적이고 객체지향적으로 좋지 않음
        1. 해당 어노테이션을 사용하는 값은 final이 붙을 수 없다 (불변성 보장 안됨)
        2. 순환 참조 방지하기 어려움
            - 생성자 주입 사용 시, 순환 참조가 있다면 실행 시점에 예외가 발생하여 조기 발견 가능
        3. 테스트가 어렵다
3. 수정자 주입 - Setter 메소드에 @Autowired를 붙이는 방법

# 컴포넌트와 빈의 차이는 무엇일까?


|  | @Bean | @Component |
| --- | --- | --- |
| 한줄평 | 개발자가 직접 제어해야 하는 객체 등록 (외부 라이브러리, 복잡한 생성 과정) | 스프링이 관리할 수 있는 애플리케이션 로직 클래스 등록 (일반적 상황) |
| 선언 위치 | 메소드 레벨 | 클래스 레벨 |
| 사용 상황 | 개발자가 컨트롤이 불가능한 외부 라이브러리가 제공하는 객체 사용 시, 복잡한 객체의 생성과 관리 (개발자가 직접 빈 생성 로직 제어 가능) | 개발자가 직접 컨트롤이 가능한 내부 클래스에 사용, 간단한 경우에 사용, AOP와 함께 사용되어 공통적인 관심사를 클래스에 적용 |
| 부가 사항 | @Bean 사용 시 @Configuration 어노테이션을 사용해야 한다(Bean만 선언하면 다른 곳에서 의존성 주입하는 데 활용할 수 없다) | - |

# 참고자료


https://dev-coco.tistory.com/69

https://velog.io/@falling_star3/Spring-Boot-%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B9%88bean%EA%B3%BC-%EC%9D%98%EC%A1%B4%EA%B4%80%EA%B3%84

https://cbw1030.tistory.com/54

https://youngjinmo.github.io/2021/06/bean-component/

https://curiousjinan.tistory.com/entry/spring-bean-component
