# WWW (World Wide Web)

인터넷에 연결된 컴퓨터를 이용해 사람들과 정보를 공유할 수 있는 공간

- 분산 클라이언트/서버 서비스

# HTTP (Hyper Text Transfer Protocol)

WWW(웹) 상에서 데이터를 주고받기 위한 프로토콜

서버와 클라이언트가 서로 데이터를 주고받기 위해 사용되는 통신 규약

## 특징

- 클라이언트와 서버 간의 요청과 응답을 통해 작동
- 다양한 종류의 데이터를 전송할 수 있도록 설계
- 웹 페이지에 포함된 각 구성 요소는 대부분 개별적인 요청을 통해 서버로부터 요청
    - 이미지 요청 따로, 정적 리소스 요청 따로 등
- 일반적으로 TCP/IP 통신 프로토콜을 기반으로 동작
- STATELESS 프로토콜 (상태가 없는 프로토콜 - 무상태성)
    - 데이터를 주고받기 위해 행하는 각각의 데이터 요청이 서로 독립적으로 관리된다
    - 이전 데이터 요청과 다음 데이터 요청이 서로 관련이 없다는 것
- 단방향성: 하나의 요청에 하나의 응답을 하는 방식

## 단점

- HTTP는 데이터를 평문으로 전송하여 도청 및 데이터 변조의 위험 존재
- 중간에 패킷을 가로채어 내용을 엿볼 수 있고 필요에 따라 수정할 수도 있기에 보안에 취약

⇒ 이를 보완하기 위해 나온 것이 HTTPS (HyperText Transfer Protocol Secure)

## HTTP의 무상태성과 비연결성

### 무상태성 (Stateless)

HTTP 통신은 기본적으로 무상태성을 가진다.
서버 간 상태 정보를 가지고 있지 않는다는 점이다.

하지만, 언제나 예외는 존재하는 법. 상태 유지가 필요한 상황도 있다. (로그인 유지 등)

- Stateful (상태 유지)
    
    클라이언트와 서버 관계에서 서버가 클라이언트의 상태를 보존함을 의미
    
    - 어떠한 상태를 유지하기 위해 어딘가(서버던 클라이언트던)에 상태 유지를 위한 데이터를 저장하고 필요 시 확인
    - 예시
        - 로그인 유지
            - 로그인 상태를 유지하기 위해서는 브라우저의 쿠키에 데이터를 저장하거나, 서버의 세션 메모리에 저장하여 상태를 유지할 수 있도록 한다.
            (물론 클라이언트의 상태 데이터를 따로 캐시 서버(Redis 등)에 저장하여 이용하기도 한다)
    - 단점
        - 내가 이용하던 서버(분산 서버 A)가 아닌, 다른 서버(분산 서버 B)를 사용해야 하는 상황에서, 서버 A는 날 알고 있지만, B는 나와 초면이 될 수 있다는 점이다.
            - 기존 서버에서만 상태 값이 저장됨 (새로운 서버에서는 상태 값이 없다는 점)
- Stateless (무상태)
    
    클라이언트와 서버 관계에서 서버가 클라이언트의 상태를 보존하지 않음
    
    - 단순히 요청이 오면 응답을 보내는 역할 수행, 상태 관리는 전적으로 클라이언트에게 책임
        - 통신에 필요한 모든 상태 정보들은 클라이언트가 가지고 있다가, 서버와 통신할 때 데이터를 실어 보내는 것
        - 서버는 단순히 요청 값을 받아 그에 맞춰 응답만 해 준다 → 서버가 바뀌어도 응답에 문제 발생 X
    - 예시
        - UDP
            - Handshaking 등의 인증 과정을 수행하지 않고 그냥 패킷을 보내기만 함
            - 서로 상태를 보고 보내도 되는지 고려하지 않음 그냥 보낸다는 점
        - HTTP (기본 상태)
    - 단점
        - 클라이언트 요청 시 더 많은 데이터가 소모
            - 요청 시 자신의 부가 정보를 매번 전달해야 하기에 더 많은 데이터가 소모
    
    ⇒ 이제 여기서 무상태를 유지하면서도 상태 유지(ex. 로그인)를 가능케 할 순 없을까? 해서 나온 것이 바로 토큰(JWT 토큰)이다.
    

### 비연결성 (Connectionless)

서버와 클라이언트의 Connection이 지속되지 않는다.

- HTTP는 기본적으로 연결을 유지하지 않는 모델
- 클라이언트가 서버에 요청을 하고, 응답을 받으면 바로 TCP/IP 연결을 끊어 연결을 유지하지 않는다
    - 연결을 유지함으로써 소모되는 자원 낭비를 줄임
- 이러한 특성은 서버 자원을 매우 효율적으로 사용할 수 있다.

👀 그런데, 그렇다면 매 요청마다 연결을 끊는다면,
Handshaking 과정이 더 자원을 낭비하는 것은 아닐까? ⇒ 단기 커넥션과 HTTP 지속 연결

- 단기 커넥션과 지속 연결
    
    위에 대한 의문에 대한 해답은 지속 연결이었다.
    
    - 단기 커넥션
        
        HTTP 초기에는 매 요청마다 연결을 끊는 방식이었다.
        
        그런데, HTML만 전송할까?
        
        자바스크립트, CSS, 이미지 파일 등 많은 자원들을 함께 요청하게 되는데, 이 때마다 연결을 종료하고 다시 연결하는 과정에서 너무나도 많은 Handshake가 발생하게 되었다.
        그로 인해, Handshake로 인한 자원 낭비 및 오버헤드 발생 가능성에 대한 우려가 존재했다.
        
    - HTTP 지속 연결
        
        그래서 이 문제를 해결하고자, 지속 연결을 통해 하나의 TCP 연결로 여러 개의 요청과 응답을 처리할 수 있도록 했다.
        
        - HTTP/1.1 버전의 Keep-Alive
            - HTTP/1.1에서 해당 기능을 표준 동작으로 지정하며,
            지속 연결의 방식으로 여러 개의 요청, 응답을 하나의 TCP 연결로 처리하게 되었다.
            - Keep-Alive 헤더를 통해 연결을 재사용하는 것이다.
            `Connection: keep-alive` 를 통해 연결 지속을 원한다는 의미를 넣어 요청을 하면 이러한 지속 연결이 가능해진다.
            - 현재는 기본적으로 keep-alive로 전달이 되며, 명시적으로 `Connection: close`를 넣을 때만 연결이 해제되도록 되어 있다.
        - HTTP Pipelining
            - 각 요청에 대한 응답을 기다리지 않고, 여러 개의 HTTP Request를 하나의 TCP/IP 패킷으로 Packing해서 요청을 보내는 것이다.
            - 하나의 Connection으로 다수의 요청과 응답을 처리할 수 있게끔 하는 것
            - 그러나, 이 기법에서는 Head Of Line Blocking(HOLB)라는 문제가 발생한다.
                - 이는 응답 처리를 미루는 방식이기에, 응답 처리가 순차적으로 처리된다는 것은 변하지 않는다.
                - 따라서, 후순위의 응답은 어찌되었든 지연되는 수밖에 없는 것이다.
                
                ⇒ 이러한 문제는 HTTP/2가 등장하며 멀티플렉싱 알고리즘으로 대체되었다.
                

## HTTP Method

클라이언트가 서버에 요청을 보낼 때 사용된다.

주로 GET, POST, PUT, DELETE, PATCH가 사용된다.

- GET: 정보 요청
- HEAD: 헤더 정보만을 요청 → 웹 서버 정보 확인, 버전 확인, 최종 수정일자 확인 등의 용도로 사용
- POST: 서버에 데이터를 전송
- PUT: 정보를 갱신하기 위해 사용 (전체 수정)
- DELETE: 정보 삭제
- OPTIONS: 서버에서 지원하는 HTTP 메서드의 목록을 요청할 때 사용
- PATCH: 리소스의 일부분을 수정
- CONNECT: 프록시 동작의 터널 접속을 변경

## HTTP 상태 코드

상태 코드에 대해서는, 아래 링크들은 참조하면 된다.

HTTP 응답 시 어떤 상태인지 전달을 해 주어야 하는데 그 때 전달되는 코드이다.

개발 시 응답 상태 코드를 잘 전달하게 되면 응답에 대한 의도도 잘 전달 될 수 있기에, 잘 생각하고 값을 반환하는 것이 좋다.

[HTTP 상태 코드 - HTTP | MDN](https://developer.mozilla.org/ko/docs/Web/HTTP/Reference/Status)
[HTTP 상태 코드 표 전체 요약 정리](https://hongong.hanbit.co.kr/http-%EC%83%81%ED%83%9C-%EC%BD%94%EB%93%9C-%ED%91%9C-1xx-5xx-%EC%A0%84%EC%B2%B4-%EC%9A%94%EC%95%BD-%EC%A0%95%EB%A6%AC/)

## HTTP의 역사

<img width="1948" height="298" alt="image" src="https://github.com/user-attachments/assets/eff4b671-99b6-440a-a1eb-5b225a837d76" />

### HTTP/0.9

- 단일 라인 요청
- 리소스에 대한 Method는 GET만 존재
- 헤더가 존재하지 않았으며, HTML 파일만 전송 가능
- 상태/오류 코드가 존재하지 않음

### HTTP/1.0

- HTTP 헤더 개념을 통해 metadata 전송을 허용하여 프로토콜을 유연하고 확장 가능하도록 함
- 버전 정보와 요청 Method가 함께 전송 가능
- 상태 코드 추가
- Content-Type 도입으로 HTML 이외의 다양한 문서 전송 가능
- 단기 커넥션 기본 지원으로, 커넥션 하나 당 요청 하나만을 처리 가능
    - Keep-Alive를 따로 설정해야 했음

### HTTP/1.1

- HTTP의 첫 번째 표준 버전
- Persistent Connection (지속 연결)
    - 지전한 timeout 동안 커넥션을 재사용 가능하게 함 (keep-alive)
    - 기존 연결에 대한 Handshaking 생략
- Pipelining
    - 앞 요청의 응답을 기다리지 않고 순차적인 여러 요청을 연속적으로 전달
    - 하나의 커넥션에 여러 요청을 한 번에 전달하는 것
    - 하지만, 동시에 여러 개의 요청을 처리해 응답으로 보내주는 것이 아님
- High Latency (높은 지연)
    - Head Of Line Blocking(HOLB) 문제가 발생
        - Pipelining 방식은 한 번 보낼 때 묶어서 요청을 보내는 것이라
        결과적으로 응답은 순차적으로 처리됨
        - 앞 요청의 응답이 너무 오래 걸리면, 뒤 요청은 Blocking 되어버림
    - RTT (Round Trip Time)
        - 하나의 Connection에 하나의 요청을 처리하는 특성 상 Handshake 반복 등 지연이 증가
    - Fat Message Headers
        - HTTP/1.1 헤더에는 많은 Meta Header가 존재
        - 전송하려는 값보다 헤더 값이 더 큰 경우도 자주 발생
    - 그 외에도 우선순위 없음, Clint-driven Transmission 등의 문제가 존재

### SPDY

웹페이지 전송 지연을 줄이고 웹 보안을 개선하는 목표로 구글에서 만든 비표준 프로토콜
압축, 다중화, 우선 순위 설정 등을 통한 전송 지연 감소를 목표로 함

이후, 이를 참고 규격으로 한 HTTP/2가 표준화되어 프로젝트 종료 

- 항상 TLS 위에서 동작 (HTTPS로 작성된 웹 사이트만 적용 가능)
- HTTP 헤더 압축
- 멀티플렉싱: 하나의 커넥션 안에서 다수의 독립적인 스트림을 동시에 처리
- 텍스트가 아닌 바이너리 프로토콜 이용
- Full-duplex interleaving & Priorization: 다른 스트림이 끼어드는 것을 허용
- Server Push

### HTTP/2

기존 HTTP 1.X 버전의 성능 향상에 초점을 맞춘 프로토콜 (기존 표준의 대체가 아닌 확장의 개념)

이에 대한 참고 규격으로 구글의 SPDY를 사용

- 메시지 전송 방식의 전환
    - 기존 전송 방식인 Text가 아닌,
    Text를 Binary화 하여 Header frame, Body frame이라는 데이터 단위를 만듦
    - 1개의 메시지는 1 또는 2개의 Header Frame과 0개 이상의 Body Frame으로 나누어 전송됨
        - 이렇게 나뉜 프레임들은 Header Frame, Data Frame 순으로 전송되어야 하기에 Stream Sequence란 번호를 붙여 같은 번호인 Frame을 Stream이라는 개념으로 구분
    - Stream, Message, Frame
        
        HTTP 요청/응답 (메시지)를 여러 개의 Frame으로 나누고, 인코딩하여 데이터를 주고받는다.
        그리고, 요청/응답 메시지는 특정 Stream에 속하며, 여러 개의 Stream은 하나의 Connection에 속함
        
        - Stream: 연결된 커넥션 내에서 하나 이상의 메시지를 양방향으로 주고 받는 양방향 바이트 흐름
        - Message: 하나의 요청과 응답을 구성하는 단위. 다수의 Frame으로 이루어진 배열 라인
        - Frame: HTTP/2.0의 가장 작은 통신 단위, Header 혹은 Data가 포함되어 있음
- 멀티플렉싱
    - 병렬 요청이 이루어지는 다중화 프로토콜 도입
        - 파이프라이닝의 단점을 멀티플렉싱으로 극복
        - 프레임이 각 요청의 스트림을 통해 전달되며, 하나의 커넥션 안에 여러 개의 스트림을 가질 수 있게 되어 동시에 여러 요청을 처리하는 다중화가 가능해짐
            - 이로 인해, 응용 계층에서의 HOL Blocking을 해결하게 됨
- 스트림 우선순위
    - Stream에 우선 순위를 부여하여 다른 스트림이 끼어드는 것(인터리빙)이 허용됨
    - 병렬적으로 이루어지기에 우선적으로 전달되어야 하는 것에 대해 가중치를 부여할 수 있음
- 흐름 제어
    - 흐름 제어를 위한 특정 알고리즘을 지정하지 않지만, 개발자가 직접 구현하여 리소스 사용과 할당을 제어할 수 있음
    - 중요한 리소스 우선 다운로드 후 나머지 재개, 이미지 일부만 가져오기 등
- 헤더 압축
    - HTTP 메시지의 헤더를 압축하여 전송
    - Message 헤더 내용 중 중복되는 필드를 재전송하지 않도록 함
        - Static/Dynamic Header Table 개념을 사용하여 중복 헤더를 검출
        - 중복되지 않은 Header 정보값은 호프만 인코딩 기법을 사용하는 HPACK 압축 방식으로 인코딩하여 처리 후 전송
- 서버 푸시
    - 단일 클라이언트 요청에 여러 응답을 보낼 수 있는 특징을 통해, 서버에서 클라이언트에게 필요한 추가적인 리소스를 Push 해줄 수 있다
    - 요청의 중복이 생기지 않도록, 모든 서버 푸시 스트림은 HTTP 헤더를 포함한 PUSH_PROMISE 프레임을 통해 시작
- HOL Blocking (in 전송 계층)
    
    TCP 프로토콜을 이용하기에 발생하는 문제
    
    - 서로 다른 Stream이 전송되고 있더라도 하나의 Stream에서 유실이 발생되거나 문제가 생기면 다른 Stream도 문제가 해결 될 때까지 지연되는 현상

### HTTP/3

QUIC를 기반으로 나온 새로운 HTTP 메이저 버전

UDP 기반, TCP+TLS+HTTP의 기능을 모두 구현하는 프로토콜 

- TCP 레벨에서의 HOL Blocking 해결
    - UDP를 사용하기에, 각 스트림은 독립적인 상태가 됨
        - QUIC Connection ID를 통해 연결 식별
    - Handshaking 과정이 존재하지 않아, 사전 작업으로 인한 오버헤드 등의 상황도 방지할 수 있음
- Secure 통신
    - 기본적으로 QUIC 프로토콜은 TLS를 포함하고 있어 암호화 및 보안을 수행해야 함
    - HTTPS의 모든 보안 속성을 지원할 수 있다는 의미
- Zero RTT Connection
    - 서버와 클라이언트 간의 Connection을 맞는 데 0 RTT를 달성
        - 이전에 서버에 연결했던 클라이언트는 해당 연결의 특정 파라미터를 캐시하여 0RTT 연결을 설정할 수 있음
        - TCP는 1RTT(100ms), TCP+TLS는 2-3RTT(200-300ms)

## HTTPS

HTTP에 S(Secure Socket)이 추가된 것 (보안 요소의 추가)

HTTPS를 사용한다면, 서버와 클라이언트 사이의 모든 통신 내용이 암호화된다.

- SSL/TLS 프로토콜을 통해 세션 데이터를 암호화 (현재는 TLS 1.2, TLS 1.3이 가장 널리 사용)
    - 보안 세션을 기반으로 데이터 암호화
    - 보안 세션이 만들어질 때, 인증 메커니즘, 키 교환 암호화 알고리즘, 해싱 알고리즘이 사용된다

### 암호화 방식

공개키 암호화(안전성)와, 대칭키 암호화 방식(속도)을 함께 사용한다.

공개 키 방식으로 대칭키를 전달하고, 서로 공유된 대칭 키를 가지고 통신하게 된다.

- 공개키 방식
    
    두 개의 서로 다른 키를 사용하여 데이터를 암호화/복호화를 진행한다. (공개키/개인키)
    
- 대칭키 방식
    
    데이터를 암호화하고 복호화하는 데 동일한 키를 사용
    
<img width="1460" height="1488" alt="image" src="https://github.com/user-attachments/assets/9316e4c0-322e-4b6b-8336-7bf0b093fee3" />

이런 식으로 동작한다.

### SEO와 HTTPS

SEO(Search Engine Optimization)은 검색 엔진 최적화를 뜻한다.

구글은 HTTPS 지원 웹사이트에 높은 검색 순위를 제공하기 위해 알고리즘을 변경 + 인증서가 설치되지 않은 웹사이트에 접속하면 ‘안전하지 않음’ 이라는 경고 메시지를 표시

⇒ 사용자에게 더 나은 보안을 제공하기에 좋은 점수를 주는 것이다.

# 주소창에 'www.google.com'을 치면 어떤 일이 발생할까?

1. 사용자 입력 & DNS 조회
    - 사용자가 브라우저에 `www.google.com` 입력
    - 브라우저가 URL 중 도메인 이름(`www.google.com`)을 DNS 서버에 질의
    - DNS 서버가 해당 도메인에 매핑된 IP 주소를 반환
2. 요청 메시지 생성 & 전송
    - 브라우저는 IP 주소와 URL 정보를 바탕으로 HTTP 요청 메시지 생성
    - 이 요청 메시지는 TCP 프로토콜을 통해 해당 IP 주소의 서버로 전달
3. 서버 처리 & 응답 생성
    - 서버는 요청받은 HTTP 메시지를 해석해, 요청한 웹 리소스(HTML, 이미지 등)를 검색하고 처리
    - 처리된 데이터로 HTTP 응답 메시지를 생성
4. 응답 전달 & 브라우저 렌더링
    - 응답 메시지는 TCP를 통해 클라이언트(사용자의 PC)로 전송
    - 브라우저는 수신한 HTTP 응답을 해석하여 웹 페이지 데이터로 변환
    - 변환된 데이터가 화면에 렌더링되어 사용자가 웹 페이지를 볼 수 있음

# 참고자료

https://bruders.tistory.com/143

https://inpa.tistory.com/entry/HTTP-%F0%9F%8C%90-%EB%B0%B1%EC%97%94%EB%93%9C-%EB%A1%9C%EB%93%9C%EB%A7%B5-HTTP%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C%EC%9A%94

https://brunch.co.kr/@sangjinkang/4

https://jins-dev.tistory.com/entry/HTTP11-%EC%9D%98-HTTP-Pipelining-%EA%B3%BC-Persistent-Connection-%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC

https://young1403.tistory.com/83

https://mark-kim.blog/HTTP2_0/

https://csj000714.tistory.com/733

https://dkswhdgur246.tistory.com/53

https://velog.io/@averycode/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-HTTP%EC%99%80-HTTPS-%EB%8F%99%EC%9E%91-%EA%B3%BC%EC%A0%95

https://rachel-kwak.github.io/2021/03/08/HTTPS.html

https://kuveminton.tistory.com/53
