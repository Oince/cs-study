# HTTP & HTTPS

애플리케이션 계층으로 웹서비스 통신에 사용

## 1️⃣ HTTP/1.0

- **특징**
    - 한 연결당 **하나의 요청/응답**만 처리
    - 매 요청마다 **TCP 3-Way Handshake 필요** → RTT 증가, 서버 부하↑
    - **헤더 재사용 불가**, 매 요청 시 중복 정보 포함
- **단점 극복 방법 (웹 개발 측면의 최적화 기법)**
    1. **이미지 스플리팅**: 여러 작은 이미지를 합쳐 하나의 스프라이트 이미지로 관리, 이를 background-image의 position을 이용하여 이미지들 표기
    2. **코드 압축(Minify)**: 개행·공백 제거 → 전송 크기 감소
    3. **이미지 Base64 인코딩**: 이미지파일을 64진법으로 이루어진 문자열로 인코딩, 이미지에 대해 HTTP 요청 필요X (단점: 크기 증가)

---

## 2️⃣ HTTP/1.1

- **특징**
    - **Persistent Connection (Keep-Alive)**: 한 번 TCP 연결 맺으면 여러 요청 처리 가능
        - max: 최대 요청 개수
        - timeout : 지정한 시간동안 연결 끊어지지 않게 지정
    - **파이프라이닝**: 단일 TCP로 응답 기다리지 않고 요청 여러 개 보냄,요청 보낸 순으로 응답 (구현 어렵고 프록시 지원 부족으로 거의 미사용)
    - **HOL Blocking (Head-of-Line Blocking)** 발생: 같은 큐에 있는 패킷이 앞 요청에 의해 지연되면 뒤 요청도 지연, 요청 개수에 비례해 대기시간 길어짐 → 성능 저하
    - **헤더 무압축** → 메타데이터 들어가 있고 무거움
- **장점**
    - 다수 요청 가능 (성능 향상)
- **단점**
    - 동시성 요청 많아지면 성능 저하 (브라우저는 보통 도메인당 6개 연결 제한)

---

## 3️⃣ HTTP/2

- **특징**
    - **하나의 TCP 연결**로 모든 요청 처리
    - 1개의 메시지가 1~2개 헤더 프레임과 0개이상 데이터 프레임으로 나뉘어 전송됨→TCP 내에서 헤더프레임 데이터프레임 순으로 전송돼야해서 각 프레임을 구분하고자 스트림 시퀀스 번호를 프레임에 붙임→ 같은 번호 프레임들을 스트림이란 개념으로 설명 → 멀티플렉싱 지원

      <img width="381" height="221" alt="Image" src="https://github.com/user-attachments/assets/e23b7d30-f753-4f09-9a8c-3d9c10ab8094" />

    - **헤더 압축 (HPACK, 허프만 코딩 압축 알고리즘) :** 문자열을 문자 단위로 쪼개 빈도수가 높은 정보는 적은 비트수, 빈도가 낮은 정보는 많은 비트수 사용, 전체 데이터 표현에 필요한 비트양 줄이는 원리
    - **서버 푸시**: 클라이언트 요청 전에 리소스 전송 (⚠️ 클라이언트가 서버가 보낸 리소스를 알지 못하고 리소스를 다시 요청한다는 점에서 크롬 등에서 2022년 제거됨)
- **장점**
    - **멀티플렉싱**: 병렬 스트림으로 데이터 서빙하여 동시에 여러 요청/응답 처리, 메시지를 독립된 프레임으로 조각내어 송수신한 후 다시 조립하여 데이터 주고받음 → HTTP/1.1의 HOL Blocking 해결
    - **헤더 압축**으로 네트워크 사용량 감소
- **제한**
    - 애플리케이션의 HOL Blocking은 해결하지만 여전히 **TCP 기반**이라 TCP 레벨에서 HOL Blocking은 존재

      (예: 스트림2의 헤더 손실 → 해당 스트림뿐 아니라 이후 패킷도 지연됨)


---

## 4️⃣ HTTPS (HTTP Secure)

- HTTP의 문제점 : 평문 통신이기 떄문에 도청 가능, 통신 상대를 확인하지 않기 때문에 위장 가능, 완전성 증명할 수 없어 변조 가능
- **정의**: HTTP + SSL/TLS → **암호화된 보안 통신**
- **위치**: 애플리케이션 계층과 전송 계층 사이 신뢰계층(SSL/TLS) 추가
- **SSL/TLS 기능**
    - 전송계층에서 보안 제공하는 프로토콜
    - 인터셉터 방지
    - 보안 세션으로 데이터 암호화(Confidentiality) : 보안세션이 만들어질 때 인증메커니즘, 키교환 암호화 알고리즘, 해싱 알고리즘 사용
    - cf)보안 세션: 보안의 시작 ~ 끝 유지되는 세션(OS가 자신의 자산 이용 허락 기간)
    - 무결성(Integrity)
    - 인증(Authentication)
- **핸드셰이크 과정 요약**
    1. **클라이언트 → 서버**: 지원 가능한 암호화 알고리즘(사이퍼 슈트) 전달
    2. **서버 → 클라이언트**:  사이버 슈트의 암호화 알고리즘  리스트 제공할 수 있는지 확인, 인증서(공개키 포함) 전송
    3. **세션키 공유 후** 데이터 암호화 통신 시작 (RTT 1~2번 소요)
- **구성 요소**
    - **사이퍼 슈트**: 프로토콜(TLS)+ AEAD사이퍼 모드+ 해싱 알고리즘(SHA256) 조합
    - **CA 인증서**: 안전한 연결을 시작할 때 필요한 공개키를 클라이언트에게 제공, 서버가 신뢰할 수 있는 서버임을 보장
        - 발급 과정 : 자신의 사이트 정보와 공개키를 CA에 제출, CA가 공개키를 해시한 값인 지문을 사용하는 CA의 비밀키를 기반으로 인증서 발급
    - **해시 알고리즘**: 데이터를 추정하기 힘들게 작고 섞여있는 조각으로 만드는 알고리즘, SHA256은 해시함수 결과값이 256비트 알고리즘
        - cf) 해시: 데이터로 매핑한 값, 해싱 : 해시함수를 이용하여 해시로 바꿈, 해시함수 : 데이터 입력받아 일정한 길이의 데이터로 바꾸는 함수
    - **AEAD 사이퍼 모드**: 데이터 암호화 알고리즘, AES_128_GCM 은 128비트키를 사용하는 표준 블록 암호화 기술과 병렬 계산에 용이한 알고리즘인 GCM이 결합된 알고리즘
    - 키교환 알고리즘 : 대수곡선 기반 ECDHE, 모듈식 기반 DHE(모두 디피 헬만 방식 기반 )
    - 디피 헬만 방식 : 공개키 값들을 공유하고 각 비밀값과 혼합값 공유 → 각자의 비밀값과 혼합 → 공통의 암호키인 PSK생성( 공격자가 PSK없으면 공격 못함)
    - SEO : 검색 엔진 최적화, 캐노니컬 설정, 메타설정, 페이지 속도 개선, 사이트맵 관리(xml)
- **HTTPS 도입 방법**
    - CA에서 인증서 발급 받아 직접 서버에 적용
    - 서버 앞단에 HTTPS 로드밸런서/HTTPS CDN 사용

---

## 5️⃣ HTTP/3

- **특징**
    - World Wide Web에서 정보 교환
    - **QUIC 프로토콜 기반 (UDP 위에서 동작)**
    - **스트림 단위 독립적 처리** → TCP HOL Blocking 문제 해결
    - **멀티플렉싱** 지원 (각 스트림 독립적)
    - 연결 수립 속도 빠름 (최초 연결 시 RTT 1번, 이후 0-RTT 가능)
    - **순방향 오류 수정 메커니즘(FEC)**: 전송한 패킷이 손실되었다면 수신 측에서 에러를 검출하고 수정하는 방식→ 낮은 패킷 손실률
    - 지연시간 감소 → 실시간 스트리밍·게임·영상에 최적
